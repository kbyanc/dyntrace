<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE oplist SYSTEM "oplist.dtd">
<!-- Automatically generated 2004-12-18 03:25:03 -0800 from ../reference/25366714.pdf -->

<oplist>
    <prefix bitmask="01100111" detail="address size" />
    <prefix bitmask="11110000" detail="LOCK" />
    <prefix bitmask="01100110" detail="operand size" />
    <prefix bitmask="00101110" detail="CS segment override" />
    <prefix bitmask="00111110" detail="DS segment override" />
    <prefix bitmask="00100110" detail="ES segment override" />
    <prefix bitmask="01100100" detail="FS segment override" />
    <prefix bitmask="01100101" detail="GS segment override" />
    <prefix bitmask="00110110" detail="SS segment override" />
    <op bitmask="00110111" mneumonic="AAA">
        <description>ASCII Adjust after Addition</description>
    </op>
    <op bitmask="1101010100001010" mneumonic="AAD">
        <description>ASCII Adjust AX before Division</description>
    </op>
    <op bitmask="1101010000001010" mneumonic="AAM">
        <description>ASCII Adjust AX after Multiply</description>
    </op>
    <op bitmask="00111111" mneumonic="AAS">
        <description>ASCII Adjust AL after Subtraction</description>
    </op>
    <op bitmask="0001000" mneumonic="ADC" detail="register to memory">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="0001000x11" mneumonic="ADC" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="0001001" mneumonic="ADC" detail="memory to register">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="0001001x11" mneumonic="ADC" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="0001010" mneumonic="ADC" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="100000xx11010" mneumonic="ADC" detail="immediate to register">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="100000xxxx010" mneumonic="ADC" detail="immediate to memory">
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>ADD with Carry</description>
    </op>
    <op bitmask="0000000" mneumonic="ADD" detail="register to memory">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Add</description>
    </op>
    <op bitmask="0000000x11" mneumonic="ADD" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Add</description>
    </op>
    <op bitmask="0000001" mneumonic="ADD" detail="memory to register">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Add</description>
    </op>
    <op bitmask="0000001x11" mneumonic="ADD" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Add</description>
    </op>
    <op bitmask="0000010" mneumonic="ADD" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Add</description>
    </op>
    <op bitmask="100000xx11000" mneumonic="ADD" detail="immediate to register">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Add</description>
    </op>
    <op bitmask="100000xxxx000" mneumonic="ADD" detail="immediate to memory">
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Add</description>
    </op>
    <op bitmask="011001100000111101011000" mneumonic="ADDPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101100011" mneumonic="ADDPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011000" mneumonic="ADDPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101100011" mneumonic="ADDPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101011000" mneumonic="ADDSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110010000011110101100011" mneumonic="ADDSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111101011000" mneumonic="ADDSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011110101100011" mneumonic="ADDSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111111010000" mneumonic="ADDSUBPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add /Sub packed DP FP numbers from XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="01100110000011111101000011" mneumonic="ADDSUBPD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add /Sub packed DP FP numbers from XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="111100100000111111010000" mneumonic="ADDSUBPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add /Sub packed SP FP numbers from XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="11110010000011111101000011" mneumonic="ADDSUBPS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add /Sub packed SP FP numbers from XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="0010000" mneumonic="AND" detail="register to memory">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Logical AND</description>
    </op>
    <op bitmask="0010000x11" mneumonic="AND" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Logical AND</description>
    </op>
    <op bitmask="0010001" mneumonic="AND" detail="memory to register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Logical AND</description>
    </op>
    <op bitmask="0010001x11" mneumonic="AND" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Logical AND</description>
    </op>
    <op bitmask="0010010" mneumonic="AND" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Logical AND</description>
    </op>
    <op bitmask="100000xx11100" mneumonic="AND" detail="immediate to register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Logical AND</description>
    </op>
    <op bitmask="100000xxxx100" mneumonic="AND" detail="immediate to memory">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Logical AND</description>
    </op>
    <op bitmask="011001100000111101010101" mneumonic="ANDNPD" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101010111" mneumonic="ANDNPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101010101" mneumonic="ANDNPS" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101010111" mneumonic="ANDNPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111101010100" mneumonic="ANDPD" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND of Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101010011" mneumonic="ANDPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND of Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101010100" mneumonic="ANDPS" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101010011" mneumonic="ANDPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical AND of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100011" mneumonic="ARPL" detail="from memory">
        <arg direction="input" type="mem" />
        <description>Adjust RPL Field of Selector</description>
    </op>
    <op bitmask="0110001111" mneumonic="ARPL" detail="from register">
        <arg direction="input" type="reg" />
        <description>Adjust RPL Field of Selector</description>
    </op>
    <op bitmask="01100010" mneumonic="BOUND">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Check Array Against Bounds</description>
    </op>
    <op bitmask="0000111110111100" mneumonic="BSF" detail="memory, register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Bit Scan Forward</description>
    </op>
    <op bitmask="000011111011110011" mneumonic="BSF" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Bit Scan Forward</description>
    </op>
    <op bitmask="0000111110111101" mneumonic="BSR" detail="memory, register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Bit Scan Reverse</description>
    </op>
    <op bitmask="000011111011110111" mneumonic="BSR" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Bit Scan Reverse</description>
    </op>
    <op bitmask="0000111111001" mneumonic="BSWAP">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Byte Swap</description>
    </op>
    <op bitmask="0000111110100011" mneumonic="BT" detail="memory, reg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <description>Bit Test</description>
    </op>
    <op bitmask="000011111010001111" mneumonic="BT" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Bit Test</description>
    </op>
    <op bitmask="000011111011101011100" mneumonic="BT" detail="register, immediate">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <description>Bit Test</description>
    </op>
    <op bitmask="0000111110111010xx100" mneumonic="BT" detail="memory, immediate">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <description>Bit Test</description>
    </op>
    <op bitmask="000011111011101011111" mneumonic="BTC" detail="register, immediate">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <description>Bit Test and Complement</description>
    </op>
    <op bitmask="0000111110111010xx111" mneumonic="BTC" detail="memory, immediate">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <description>Bit Test and Complement</description>
    </op>
    <op bitmask="0000111110111011" mneumonic="BTC" detail="memory, reg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <description>Bit Test and Complement</description>
    </op>
    <op bitmask="000011111011101111" mneumonic="BTC" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Bit Test and Complement</description>
    </op>
    <op bitmask="0000111110110011" mneumonic="BTR" detail="memory, reg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <description>Bit Test and Reset</description>
    </op>
    <op bitmask="000011111011001111" mneumonic="BTR" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Bit Test and Reset</description>
    </op>
    <op bitmask="000011111011101011110" mneumonic="BTR" detail="register, immediate">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <description>Bit Test and Reset</description>
    </op>
    <op bitmask="0000111110111010xx110" mneumonic="BTR" detail="memory, immediate">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <description>Bit Test and Reset</description>
    </op>
    <op bitmask="0000111110101011" mneumonic="BTS" detail="memory, reg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <description>Bit Test and Set</description>
    </op>
    <op bitmask="000011111010101111" mneumonic="BTS" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Bit Test and Set</description>
    </op>
    <op bitmask="000011111011101011101" mneumonic="BTS" detail="register, immediate">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <description>Bit Test and Set</description>
    </op>
    <op bitmask="0000111110111010xx101" mneumonic="BTS" detail="memory, immediate">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <description>Bit Test and Set</description>
    </op>
    <op bitmask="10011010" mneumonic="CALL" detail="direct">
        <arg direction="input" type="imm" />
        <description>Call Procedure (in other segment)</description>
    </op>
    <op bitmask="11101000" mneumonic="CALL" detail="direct">
        <arg direction="input" type="imm" />
        <description>Call Procedure (in same segment)</description>
    </op>
    <op bitmask="1111111111010" mneumonic="CALL" detail="register indirect">
        <arg direction="input" type="reg" />
        <description>Call Procedure (in same segment)</description>
    </op>
    <op bitmask="11111111xx010" mneumonic="CALL" detail="memory indirect">
        <arg direction="input" type="mem" />
        <description>Call Procedure (in same segment)</description>
    </op>
    <op bitmask="11111111xx011" mneumonic="CALL" detail="indirect">
        <arg direction="input" type="reg" />
        <description>Call Procedure (in other segment)</description>
    </op>
    <op bitmask="10011000" mneumonic="CBW/CWDE">
        <description>Convert Word to Doubleword</description>
    </op>
    <op bitmask="10011001" mneumonic="CDQ/CWD">
        <description>Convert Word to Doubleword</description>
    </op>
    <op bitmask="11111000" mneumonic="CLC">
        <description>Clear Carry Flag</description>
    </op>
    <op bitmask="11111100" mneumonic="CLD">
        <description>Clear Direction Flag</description>
    </op>
    <op bitmask="0000111110101110" mneumonic="CLFLUSH" detail="mem">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Flush Cache Line</description>
    </op>
    <op bitmask="11111010" mneumonic="CLI">
        <description>Clear Interrupt Flag</description>
    </op>
    <op bitmask="0000111100000110" mneumonic="CLTS">
        <description>Clear Task-Switched Flag in CR0</description>
    </op>
    <op bitmask="11110101" mneumonic="CMC">
        <description>Complement Carry Flag</description>
    </op>
    <op bitmask="0000111101000000" mneumonic="CMOVcc" detail="memory to register" conditional="O">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Overflow</description>
    </op>
    <op bitmask="000011110100000011" mneumonic="CMOVcc" detail="register2 to register1" conditional="O">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Overflow</description>
    </op>
    <op bitmask="0000111101000001" mneumonic="CMOVcc" detail="memory to register" conditional="NO">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: No overflow</description>
    </op>
    <op bitmask="000011110100000111" mneumonic="CMOVcc" detail="register2 to register1" conditional="NO">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: No overflow</description>
    </op>
    <op bitmask="0000111101000010" mneumonic="CMOVcc" detail="memory to register" conditional="B">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Below</description>
    </op>
    <op bitmask="000011110100001011" mneumonic="CMOVcc" detail="register2 to register1" conditional="B">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Below</description>
    </op>
    <op bitmask="0000111101000011" mneumonic="CMOVcc" detail="memory to register" conditional="NB">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not below</description>
    </op>
    <op bitmask="000011110100001111" mneumonic="CMOVcc" detail="register2 to register1" conditional="NB">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not below</description>
    </op>
    <op bitmask="0000111101000100" mneumonic="CMOVcc" detail="memory to register" conditional="E">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Equals</description>
    </op>
    <op bitmask="000011110100010011" mneumonic="CMOVcc" detail="register2 to register1" conditional="E">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Equals</description>
    </op>
    <op bitmask="0000111101000101" mneumonic="CMOVcc" detail="memory to register" conditional="NE">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not equals</description>
    </op>
    <op bitmask="000011110100010111" mneumonic="CMOVcc" detail="register2 to register1" conditional="NE">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not equals</description>
    </op>
    <op bitmask="0000111101000110" mneumonic="CMOVcc" detail="memory to register" conditional="NA">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not above</description>
    </op>
    <op bitmask="000011110100011011" mneumonic="CMOVcc" detail="register2 to register1" conditional="NA">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not above</description>
    </op>
    <op bitmask="0000111101000111" mneumonic="CMOVcc" detail="memory to register" conditional="A">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Above</description>
    </op>
    <op bitmask="000011110100011111" mneumonic="CMOVcc" detail="register2 to register1" conditional="A">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Above</description>
    </op>
    <op bitmask="0000111101001000" mneumonic="CMOVcc" detail="memory to register" conditional="S">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Sign</description>
    </op>
    <op bitmask="000011110100100011" mneumonic="CMOVcc" detail="register2 to register1" conditional="S">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Sign</description>
    </op>
    <op bitmask="0000111101001001" mneumonic="CMOVcc" detail="memory to register" conditional="NS">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not sign</description>
    </op>
    <op bitmask="000011110100100111" mneumonic="CMOVcc" detail="register2 to register1" conditional="NS">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not sign</description>
    </op>
    <op bitmask="0000111101001010" mneumonic="CMOVcc" detail="memory to register" conditional="P">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Parity</description>
    </op>
    <op bitmask="000011110100101011" mneumonic="CMOVcc" detail="register2 to register1" conditional="P">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Parity</description>
    </op>
    <op bitmask="0000111101001011" mneumonic="CMOVcc" detail="memory to register" conditional="NP">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not parity</description>
    </op>
    <op bitmask="000011110100101111" mneumonic="CMOVcc" detail="register2 to register1" conditional="NP">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not parity</description>
    </op>
    <op bitmask="0000111101001100" mneumonic="CMOVcc" detail="memory to register" conditional="L">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Less than</description>
    </op>
    <op bitmask="000011110100110011" mneumonic="CMOVcc" detail="register2 to register1" conditional="L">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Less than</description>
    </op>
    <op bitmask="0000111101001101" mneumonic="CMOVcc" detail="memory to register" conditional="NL">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not less than</description>
    </op>
    <op bitmask="000011110100110111" mneumonic="CMOVcc" detail="register2 to register1" conditional="NL">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not less than</description>
    </op>
    <op bitmask="0000111101001110" mneumonic="CMOVcc" detail="memory to register" conditional="NG">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not greater than</description>
    </op>
    <op bitmask="000011110100111011" mneumonic="CMOVcc" detail="register2 to register1" conditional="NG">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Not greater than</description>
    </op>
    <op bitmask="0000111101001111" mneumonic="CMOVcc" detail="memory to register" conditional="G">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Greater than</description>
    </op>
    <op bitmask="000011110100111111" mneumonic="CMOVcc" detail="register2 to register1" conditional="G">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Conditional Move: Greater than</description>
    </op>
    <op bitmask="0011100" mneumonic="CMP" detail="memory with register">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="0011100x11" mneumonic="CMP" detail="register1 with register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="0011101" mneumonic="CMP" detail="register with memory">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="0011101x11" mneumonic="CMP" detail="register2 with register1">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="0011110" mneumonic="CMP" detail="immediate with AL, AX, or EAX">
        <arg direction="input" type="imm" />
        <arg direction="input" type="reg" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="100000xx11111" mneumonic="CMP" detail="immediate with register">
        <arg direction="input" type="imm" />
        <arg direction="input" type="reg" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="100000xxxx111" mneumonic="CMP" detail="immediate with memory">
        <arg direction="input" type="imm" />
        <arg direction="input" type="mem" />
        <description>Compare Two Operands</description>
    </op>
    <op bitmask="011001100000111111000010" mneumonic="CMPPD" detail="mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Packed Double-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="01100110000011111100001011" mneumonic="CMPPD" detail="xmmreg to xmmreg, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Packed Double-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="0000111111000010" mneumonic="CMPPS" detail="mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011111100001011" mneumonic="CMPPS" detail="xmmreg to xmmreg, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="1010011" mneumonic="CMPS/CMPSB/CMPSW/CMPSD">
        <description>Compare String Operands</description>
    </op>
    <op bitmask="111100100000111111000010" mneumonic="CMPSD" detail="mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Scalar Double-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="11110010000011111100001011" mneumonic="CMPSD" detail="xmmreg to xmmreg, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Scalar Double-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="111100110000111111000010" mneumonic="CMPSS" detail="mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Scalar Single-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="11110011000011111100001011" mneumonic="CMPSS" detail="xmmreg to xmmreg, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <description>Compare Scalar Single-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="000011111011000" mneumonic="CMPXCHG" detail="memory, register">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <arg direction="output" type="reg" />
        <description>Compare and Exchange</description>
    </op>
    <op bitmask="000011111011000x11" mneumonic="CMPXCHG" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <arg direction="output" type="reg" />
        <description>Compare and Exchange</description>
    </op>
    <op bitmask="0000111111000111xx001" mneumonic="CMPXCHG8B" detail="memory, register">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <arg direction="output" type="reg" />
        <description>Compare and Exchange 8 Bytes</description>
    </op>
    <op bitmask="011001100000111100101111" mneumonic="COMISD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <description>Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="01100110000011110010111111" mneumonic="COMISD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <description>Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="0000111100101111" mneumonic="COMISS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <description>Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="000011110010111111" mneumonic="COMISS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <description>Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="0000111110100010" mneumonic="CPUID">
        <description>CPU Identification</description>
    </op>
    <op bitmask="111100110000111111100110" mneumonic="CVTDQ2PD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011111110011011" mneumonic="CVTDQ2PD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011011" mneumonic="CVTDQ2PS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101101111" mneumonic="CVTDQ2PS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111111100110" mneumonic="CVTPD2DQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="11110010000011111110011011" mneumonic="CVTPD2DQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="011001100000111100101101" mneumonic="CVTPD2PI" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="01100110000011110010110111" mneumonic="CVTPD2PI" detail="xmmreg to mmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mmreg" />
        <description>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="011001100000111101011010" mneumonic="CVTPD2PS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101101011" mneumonic="CVTPD2PS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111100101010" mneumonic="CVTPI2PD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110010101011" mneumonic="CVTPI2PD" detail="mmreg to xmmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100101010" mneumonic="CVTPI2PS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110010101011" mneumonic="CVTPI2PS" detail="mmreg to xmmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111101011011" mneumonic="CVTPS2DQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="01100110000011110101101111" mneumonic="CVTPS2DQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="0000111101011010" mneumonic="CVTPS2PD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101101011" mneumonic="CVTPS2PD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100101101" mneumonic="CVTPS2PI" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="000011110010110111" mneumonic="CVTPS2PI" detail="xmmreg to mmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mmreg" />
        <description>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="111100100000111100101101" mneumonic="CVTSD2SI" detail="mem to r32">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="11110010000011110010110111" mneumonic="CVTSD2SI" detail="xmmreg to r32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="111100100000111101011010" mneumonic="CVTSD2SS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110010000011110101101011" mneumonic="CVTSD2SS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100100000111100101010" mneumonic="CVTSI2SD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110010000011110010101011" mneumonic="CVTSI2SD" detail="r32 to xmmreg1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100110000111100101010" mneumonic="CVTSI2SS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110010101011" mneumonic="CVTSI2SS" detail="r32 to xmmreg1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100110000111101011010" mneumonic="CVTSS2SD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110101101011" mneumonic="CVTSS2SD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Covert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100110000111100101101" mneumonic="CVTSS2SI" detail="mem to r32">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="11110011000011110010110111" mneumonic="CVTSS2SI" detail="xmmreg to r32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="011001100000111111100110" mneumonic="CVTTPD2DQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert With Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="01100110000011111110011011" mneumonic="CVTTPD2DQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert With Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="011001100000111100101100" mneumonic="CVTTPD2PI" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="01100110000011110010110011" mneumonic="CVTTPD2PI" detail="xmmreg to mmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mmreg" />
        <description>Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="111100110000111101011011" mneumonic="CVTTPS2DQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Convert With Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="11110011000011110101101111" mneumonic="CVTTPS2DQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Convert With Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="0000111100101100" mneumonic="CVTTPS2PI" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="000011110010110011" mneumonic="CVTTPS2PI" detail="xmmreg to mmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mmreg" />
        <description>Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</description>
    </op>
    <op bitmask="111100100000111100101100" mneumonic="CVTTSD2SI" detail="mem to r32">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="11110010000011110010110011" mneumonic="CVTTSD2SI" detail="xmmreg to r32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="111100110000111100101100" mneumonic="CVTTSS2SI" detail="mem to r32">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="11110011000011110010110011" mneumonic="CVTTSS2SI" detail="xmmreg to r32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer</description>
    </op>
    <op bitmask="00100111" mneumonic="DAA">
        <description>Decimal Adjust AL after Addition</description>
    </op>
    <op bitmask="00101111" mneumonic="DAS">
        <description>Decimal Adjust AL after Subtraction</description>
    </op>
    <op bitmask="01001" mneumonic="DEC" detail="register (alternate encoding)">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Decrement by 1</description>
    </op>
    <op bitmask="1111111x11001" mneumonic="DEC" detail="register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Decrement by 1</description>
    </op>
    <op bitmask="1111111xxx001" mneumonic="DEC" detail="memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Decrement by 1</description>
    </op>
    <op bitmask="1111011x11110" mneumonic="DIV" detail="AL, AX, or EAX by register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Unsigned Divide</description>
    </op>
    <op bitmask="1111011xxx110" mneumonic="DIV" detail="AL, AX, or EAX by memory">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Unsigned Divide</description>
    </op>
    <op bitmask="011001100000111101011110" mneumonic="DIVPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101111011" mneumonic="DIVPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011110" mneumonic="DIVPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101111011" mneumonic="DIVPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101011110" mneumonic="DIVSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110010000011110101111011" mneumonic="DIVSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111101011110" mneumonic="DIVSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011110101111011" mneumonic="DIVSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Divide Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101110111" mneumonic="EMMS">
        <description>Empty MMX technology state</description>
    </op>
    <op bitmask="11001000" mneumonic="ENTER">
        <arg direction="input" type="imm" />
        <arg direction="input" type="imm" />
        <description>Make Stack Frame for High Level Procedure</description>
    </op>
    <op bitmask="1101100111110000" mneumonic="F2XM1">
        <description>Compute 2^ST(0) -1</description>
    </op>
    <op bitmask="1101100111100001" mneumonic="FABS">
        <description>Absolute Value</description>
    </op>
    <op bitmask="11011000xx000" mneumonic="FADD" detail="ST(0) = ST(0) + 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Add</description>
    </op>
    <op bitmask="11011100xx000" mneumonic="FADD" detail="ST(0) = ST(0) + 64-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Add</description>
    </op>
    <op bitmask="1101111000" mneumonic="FADD" detail="ST(d) = ST(0) + ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Add</description>
    </op>
    <op bitmask="1101111011000" mneumonic="FADDP" detail="ST(0) = ST(0) + ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Add and Pop</description>
    </op>
    <op bitmask="11011111xx100" mneumonic="FBLD">
        <description>Load Binary Coded Decimal</description>
    </op>
    <op bitmask="11011111xx110" mneumonic="FBSTP">
        <description>Store Binary Coded Decimal and Pop</description>
    </op>
    <op bitmask="1101100111100000" mneumonic="FCHS">
        <description>Change Sign</description>
    </op>
    <op bitmask="1101101111100010" mneumonic="FCLEX">
        <description>Clear Exceptions</description>
    </op>
    <op bitmask="1101101011000" mneumonic="FCMOVcc" detail="move if below (B)" conditional="B">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if below (B)</description>
    </op>
    <op bitmask="1101101011001" mneumonic="FCMOVcc" detail="move if equal (E)" conditional="E">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if equal (E)</description>
    </op>
    <op bitmask="1101101011010" mneumonic="FCMOVcc" detail="move if below or equal (BE)" conditional="BE">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if below or equal (BE)</description>
    </op>
    <op bitmask="1101101011011" mneumonic="FCMOVcc" detail="move if unordered (U)" conditional="U">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if unordered (U)</description>
    </op>
    <op bitmask="1101101111000" mneumonic="FCMOVcc" detail="move if not below (NB)" conditional="NB">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if not below (NB)</description>
    </op>
    <op bitmask="1101101111001" mneumonic="FCMOVcc" detail="move if not equal (NE)" conditional="NE">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if not equal (NE)</description>
    </op>
    <op bitmask="1101101111010" mneumonic="FCMOVcc" detail="move if not below or equal (NBE)" conditional="NBE">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if not below or equal (NBE)</description>
    </op>
    <op bitmask="1101101111011" mneumonic="FCMOVcc" detail="move if not unordered (NU)" conditional="NU">
        <arg direction="input" type="ST(i)" />
        <description>Conditional Move on EFLAG Register Condition Codes: move if not unordered (NU)</description>
    </op>
    <op bitmask="1101100011010" mneumonic="FCOM" detail="ST(i)">
        <arg direction="input" type="ST(i)" />
        <description>Compare Real</description>
    </op>
    <op bitmask="11011000xx010" mneumonic="FCOM" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Real</description>
    </op>
    <op bitmask="11011100xx010" mneumonic="FCOM" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Real</description>
    </op>
    <op bitmask="1101101111110" mneumonic="FCOMI">
        <arg direction="input" type="ST(i)" />
        <description>Compare Real and Set EFLAGS</description>
    </op>
    <op bitmask="1101111111110" mneumonic="FCOMIP">
        <arg direction="input" type="ST(i)" />
        <description>Compare Real, Set EFLAGS, and Pop</description>
    </op>
    <op bitmask="1101100011011" mneumonic="FCOMP" detail="ST(i)">
        <arg direction="input" type="ST(i)" />
        <description>Compare Real and Pop</description>
    </op>
    <op bitmask="11011000xx011" mneumonic="FCOMP" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Real and Pop</description>
    </op>
    <op bitmask="11011100xx011" mneumonic="FCOMP" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Real and Pop</description>
    </op>
    <op bitmask="1101111011011001" mneumonic="FCOMPP">
        <description>Compare Real and Pop Twice</description>
    </op>
    <op bitmask="1101100111111111" mneumonic="FCOS">
        <description>Cosine of ST(0)</description>
    </op>
    <op bitmask="1101100111110110" mneumonic="FDECSTP">
        <description>Decrement Stack-Top Pointer</description>
    </op>
    <op bitmask="11011000xx110" mneumonic="FDIV" detail="ST(0) = ST(0) / 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Divide</description>
    </op>
    <op bitmask="11011100xx110" mneumonic="FDIV" detail="ST(0) = ST(0) / 64-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Divide</description>
    </op>
    <op bitmask="110111111" mneumonic="FDIV/FDIVR" detail="ST(d) = ST(0) / ST(i), ST(d) = ST(i) / ST(0)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Divide</description>
    </op>
    <op bitmask="1101111011111" mneumonic="FDIVP" detail="ST(0) = ST(0) / ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Divide and Pop</description>
    </op>
    <op bitmask="11011000xx111" mneumonic="FDIVR" detail="ST(0) = 32-bit memory / ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Divide</description>
    </op>
    <op bitmask="11011100xx111" mneumonic="FDIVR" detail="ST(0) = 64-bit memory / ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Divide</description>
    </op>
    <op bitmask="1101111011110" mneumonic="FDIVRP" detail="ST(0) = ST(i) / ST(0)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Divide and Pop</description>
    </op>
    <op bitmask="1101110111000" mneumonic="FFREE">
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Free ST(i) Register</description>
    </op>
    <op bitmask="11011010xx000" mneumonic="FIADD" detail="ST(0) = ST(0) + 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Add Integer</description>
    </op>
    <op bitmask="11011110xx000" mneumonic="FIADD" detail="ST(0) = ST(0) + 16-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Add Integer</description>
    </op>
    <op bitmask="11011010xx010" mneumonic="FICOM" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Integer</description>
    </op>
    <op bitmask="11011110xx010" mneumonic="FICOM" detail="16-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Integer</description>
    </op>
    <op bitmask="11011010xx011" mneumonic="FICOMP" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Integer and Pop</description>
    </op>
    <op bitmask="11011110xx011" mneumonic="FICOMP" detail="16-bit memory">
        <arg direction="input" type="mem" />
        <description>Compare Integer and Pop</description>
    </op>
    <op bitmask="11011010xx110" mneumonic="FIDIV" detail="ST(0) = ST(0) / 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>FIDIV</description>
    </op>
    <op bitmask="11011110xx110" mneumonic="FIDIV" detail="ST(0) = ST(0) / 16-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>FIDIV</description>
    </op>
    <op bitmask="11011010xx111" mneumonic="FIDIVR" detail="ST(0) = 32-bit memory / ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>FIDIVR</description>
    </op>
    <op bitmask="11011110xx111" mneumonic="FIDIVR" detail="ST(0) = 16-bit memory / ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>FIDIVR</description>
    </op>
    <op bitmask="11011011xx000" mneumonic="FILD" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Load Integer</description>
    </op>
    <op bitmask="11011111xx000" mneumonic="FILD" detail="16-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Load Integer</description>
    </op>
    <op bitmask="11011111xx101" mneumonic="FILD" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Load Integer</description>
    </op>
    <op bitmask="11011010xx001" mneumonic="FIMUL" detail="ST(0) = ST(0) * 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>FIMUL</description>
    </op>
    <op bitmask="11011110xx001" mneumonic="FIMUL" detail="ST(0) = ST(0) * 16-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>FIMUL</description>
    </op>
    <op bitmask="1101100111110111" mneumonic="FINCSTP">
        <description>Increment Stack Pointer</description>
    </op>
    <op bitmask="1101101111100011" mneumonic="FINIT">
	<description>Initialize FPU</description>
    </op>
    <op bitmask="11011011xx010" mneumonic="FIST" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Integer</description>
    </op>
    <op bitmask="11011111xx010" mneumonic="FIST" detail="16-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Integer</description>
    </op>
    <op bitmask="11011011xx011" mneumonic="FISTP" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Integer and Pop</description>
    </op>
    <op bitmask="11011111xx011" mneumonic="FISTP" detail="16-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Integer and Pop</description>
    </op>
    <op bitmask="11011111xx111" mneumonic="FISTP" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Integer and Pop</description>
    </op>
    <op bitmask="11011011xx001" mneumonic="FISTTP" detail="m32int">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Store ST in int32 (chop) and pop</description>
    </op>
    <op bitmask="11011101xx001" mneumonic="FISTTP" detail="m64int">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Store ST in int64 (chop) and pop</description>
    </op>
    <op bitmask="11011111xx001" mneumonic="FISTTP" detail="m16int">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Store ST in int16 (chop) and pop</description>
    </op>
    <op bitmask="11011010xx100" mneumonic="FISUB" detail="ST(0) = ST(0) - 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>FISUB</description>
    </op>
    <op bitmask="11011110xx100" mneumonic="FISUB" detail="ST(0) = ST(0) - 16-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>FISUB</description>
    </op>
    <op bitmask="11011010xx101" mneumonic="FISUBR" detail="ST(0) = 32-bit memory - ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>FISUBR</description>
    </op>
    <op bitmask="11011110xx101" mneumonic="FISUBR" detail="ST(0) = 16-bit memory - ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>FISUBR</description>
    </op>
    <op bitmask="1101100111000" mneumonic="FLD" detail="ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Load Real</description>
    </op>
    <op bitmask="11011001xx000" mneumonic="FLD" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Load Real</description>
    </op>
    <op bitmask="11011011xx101" mneumonic="FLD" detail="80-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Load Real</description>
    </op>
    <op bitmask="11011101xx000" mneumonic="FLD" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Load Real</description>
    </op>
    <op bitmask="1101100111101000" mneumonic="FLD1">
        <arg direction="output" type="ST(0)" />
        <description>Load +1.0 into ST(0)</description>
    </op>
    <op bitmask="11011001xx101" mneumonic="FLDCW">
        <description>Load Control Word</description>
    </op>
    <op bitmask="11011001xx100" mneumonic="FLDENV">
        <description>Load FPU Environment</description>
    </op>
    <op bitmask="1101100111101010" mneumonic="FLDL2E">
        <arg direction="output" type="ST(0)" />
        <description>Load log2() into ST(0)</description>
    </op>
    <op bitmask="1101100111101001" mneumonic="FLDL2T">
        <arg direction="output" type="ST(0)" />
        <description>Load log2(10) into ST(0)</description>
    </op>
    <op bitmask="1101100111101100" mneumonic="FLDLG2">
        <arg direction="output" type="ST(0)" />
        <description>Load log10(2) into ST(0)</description>
    </op>
    <op bitmask="1101100111101101" mneumonic="FLDLN2">
        <arg direction="output" type="ST(0)" />
        <description>Load log(2) into ST(0)</description>
    </op>
    <op bitmask="1101100111101011" mneumonic="FLDPI">
        <arg direction="output" type="ST(0)" />
        <description>Load into ST(0)</description>
    </op>
    <op bitmask="1101100111101110" mneumonic="FLDZ">
        <arg direction="output" type="ST(0)" />
        <description>Load +0.0 into ST(0)</description>
    </op>
    <op bitmask="11011000xx001" mneumonic="FMUL" detail="ST(0) = ST(0) * 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Multiply</description>
    </op>
    <op bitmask="11011100xx001" mneumonic="FMUL" detail="ST(0) = ST(0) * 64-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Multiply</description>
    </op>
    <op bitmask="1101111001" mneumonic="FMUL" detail="ST(d) = ST(0) * ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Multiply</description>
    </op>
    <op bitmask="1101111011001" mneumonic="FMULP" detail="ST(i) = ST(0) * ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Multiply</description>
    </op>
    <op bitmask="1101100111010000" mneumonic="FNOP">
        <description>No Operation</description>
    </op>
    <op bitmask="1101100111110011" mneumonic="FPATAN">
        <description>Partial Arctangent</description>
    </op>
    <op bitmask="1101100111111000" mneumonic="FPREM">
        <description>Partial Remainder</description>
    </op>
    <op bitmask="1101100111110101" mneumonic="FPREM1">
        <description>Partial Remainder (IEEE)</description>
    </op>
    <op bitmask="1101100111110010" mneumonic="FPTAN">
        <description>Partial Tangent</description>
    </op>
    <op bitmask="1101100111111100" mneumonic="FRNDINT">
        <description>Round to Integer</description>
    </op>
    <op bitmask="11011101xx100" mneumonic="FRSTOR">
        <description>Restore FPU State</description>
    </op>
    <op bitmask="11011101xx110" mneumonic="FSAVE">
        <description>Store FPU State</description>
    </op>
    <op bitmask="1101100111111101" mneumonic="FSCALE">
        <description>Scale</description>
    </op>
    <op bitmask="1101100111111110" mneumonic="FSIN">
        <description>Sine</description>
    </op>
    <op bitmask="1101100111111011" mneumonic="FSINCOS">
        <description>Sine and Cosine</description>
    </op>
    <op bitmask="1101100111111010" mneumonic="FSQRT">
        <description>Square Root</description>
    </op>
    <op bitmask="11011001xx010" mneumonic="FST" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real</description>
    </op>
    <op bitmask="1101110111010" mneumonic="FST" detail="ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real</description>
    </op>
    <op bitmask="11011101xx010" mneumonic="FST" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real</description>
    </op>
    <op bitmask="11011001xx111" mneumonic="FSTCW">
        <description>Store Control Word</description>
    </op>
    <op bitmask="11011001xx110" mneumonic="FSTENV">
        <description>Store FPU Environment</description>
    </op>
    <op bitmask="11011001xx011" mneumonic="FSTP" detail="32-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real and Pop</description>
    </op>
    <op bitmask="11011011xx111" mneumonic="FSTP" detail="80-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real and Pop</description>
    </op>
    <op bitmask="1101110111011" mneumonic="FSTP" detail="ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real and Pop</description>
    </op>
    <op bitmask="11011101xx011" mneumonic="FSTP" detail="64-bit memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Store Real and Pop</description>
    </op>
    <op bitmask="11011101xx111" mneumonic="FSTSW">
        <arg direction="output" type="Memory" />
        <description>Store Status Word into Memory</description>
    </op>
    <op bitmask="1101111111100000" mneumonic="FSTSW">
        <arg direction="output" type="AX" />
        <description>Store Status Word into AX</description>
    </op>
    <op bitmask="11011000xx100" mneumonic="FSUB" detail="ST(0) = ST(0) - 32-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Subtract</description>
    </op>
    <op bitmask="11011100xx100" mneumonic="FSUB" detail="ST(0) = ST(0) - 64-bit memory">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="ST(i)" />
        <description>Subtract</description>
    </op>
    <op bitmask="110111110" mneumonic="FSUB/FSUBR" detail="ST(d) = ST(0) - ST(i), ST(d) = ST(i) - ST(0)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Subtract</description>
    </op>
    <op bitmask="1101111011101" mneumonic="FSUBP" detail="ST(0) = ST(0) - ST(i)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Subtract and Pop</description>
    </op>
    <op bitmask="11011000xx101" mneumonic="FSUBR" detail="ST(0) = 32-bit memory - ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Subtract</description>
    </op>
    <op bitmask="11011100xx101" mneumonic="FSUBR" detail="ST(0) = 64-bit memory - ST(0)">
        <arg direction="input" type="mem" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Subtract</description>
    </op>
    <op bitmask="1101111011100" mneumonic="FSUBRP" detail="ST(i) = ST(i) - ST(0)">
        <arg direction="input" type="ST(i)" />
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Reverse Subtract and Pop</description>
    </op>
    <op bitmask="1101100111100100" mneumonic="FTST">
        <description>Test</description>
    </op>
    <op bitmask="1101110111100" mneumonic="FUCOM">
        <arg direction="input" type="ST(i)" />
        <description>Unordered Compare Real</description>
    </op>
    <op bitmask="1101101111101" mneumonic="FUCOMI">
        <arg direction="input" type="ST(i)" />
        <description>Unorderd Compare Real and Set EFLAGS</description>
    </op>
    <op bitmask="1101111111101" mneumonic="FUCOMIP">
        <arg direction="input" type="ST(i)" />
        <description>Unorderd Compare Real, Set EFLAGS, and Pop</description>
    </op>
    <op bitmask="1101110111101" mneumonic="FUCOMP">
        <arg direction="input" type="ST(i)" />
        <description>Unordered Compare Real and Pop</description>
    </op>
    <op bitmask="1101101011101001" mneumonic="FUCOMPP">
        <description>Unordered Compare Real and Pop Twice</description>
    </op>
    <op bitmask="1101100111100101" mneumonic="FXAM">
        <description>Examine</description>
    </op>
    <op bitmask="1101100111001" mneumonic="FXCH">
        <arg direction="input" type="ST(i)" />
        <arg direction="output" type="ST(i)" />
        <description>Exchange ST(0) and ST(i)</description>
    </op>
    <op bitmask="0000111110101110xx001" mneumonic="FXRSTOR">
        <description>Restore x87 FPU, MMX, SSE, and SSE2 State</description>
    </op>
    <op bitmask="0000111110101110xx000" mneumonic="FXSAVE">
        <description>Save x87 FPU, MMX, SSE, and SSE2 State</description>
    </op>
    <op bitmask="1101100111110100" mneumonic="FXTRACT">
        <description>Extract Exponent and Significand</description>
    </op>
    <op bitmask="1101100111110001" mneumonic="FYL2X">
        <description>ST(1) * log2(ST(0))</description>
    </op>
    <op bitmask="1101100111111001" mneumonic="FYL2XP1">
        <description>ST(1) * log2(ST(0) + 1.0)</description>
    </op>
    <op bitmask="011001100000111101111100" mneumonic="HADDPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add horizontally packed DP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="01100110000011110111110011" mneumonic="HADDPD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add horizontally packed DP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="111100100000111101111100" mneumonic="HADDPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add horizontally packed SP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="11110010000011110111110011" mneumonic="HADDPS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add horizontally packed SP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="11110100" mneumonic="HLT">
        <description>Halt</description>
    </op>
    <op bitmask="011001100000111101111101" mneumonic="HSUBPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Sub horizontally packed DP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="01100110000011110111110111" mneumonic="HSUBPD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Sub horizontally packed DP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="111100100000111101111101" mneumonic="HSUBPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Sub horizontally packed SP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="11110010000011110111110111" mneumonic="HSUBPS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Sub horizontally packed SP FP numbers XMM2/Mem to XMM1</description>
    </op>
    <op bitmask="1111011x11111" mneumonic="IDIV" detail="AL, AX, or EAX by register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Signed Divide</description>
    </op>
    <op bitmask="1111011xxx111" mneumonic="IDIV" detail="AL, AX, or EAX by memory">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Signed Divide</description>
    </op>
    <op bitmask="0000111110101111" mneumonic="IMUL" detail="register with memory">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Signed Multiply</description>
    </op>
    <op bitmask="000011111010111111" mneumonic="IMUL" detail="register1 with register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Signed Multiply</description>
    </op>
    <op bitmask="011010x1" mneumonic="IMUL" detail="memory with immediate to register">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Signed Multiply</description>
    </op>
    <op bitmask="011010x111" mneumonic="IMUL" detail="register1 with immediate to register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Signed Multiply</description>
    </op>
    <op bitmask="1111011x11101" mneumonic="IMUL" detail="AL, AX, or EAX with register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Signed Multiply</description>
    </op>
    <op bitmask="1111011xxx101" mneumonic="IMUL" detail="AL, AX, or EAX with memory">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Signed Multiply</description>
    </op>
    <op bitmask="1110010" mneumonic="IN" detail="fixed port">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Input From Port</description>
    </op>
    <op bitmask="1110110" mneumonic="IN" detail="variable port">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Input From Port</description>
    </op>
    <op bitmask="01000" mneumonic="INC" detail="reg (alternate encoding)">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Increment by 1</description>
    </op>
    <op bitmask="1111111x11000" mneumonic="INC" detail="reg">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Increment by 1</description>
    </op>
    <op bitmask="1111111xxx000" mneumonic="INC" detail="memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Increment by 1</description>
    </op>
    <op bitmask="0110110" mneumonic="INS">
        <description>Input from DX Port</description>
    </op>
    <op bitmask="11001100" mneumonic="INT">
        <description>Single-Step Interrupt 3</description>
    </op>
    <op bitmask="11001101" mneumonic="INT n">
        <arg direction="input" type="imm" />
        <description>Interrupt Type n</description>
    </op>
    <op bitmask="11001110" mneumonic="INTO">
        <description>Interrupt 4 on Overflow</description>
    </op>
    <op bitmask="0000111100001000" mneumonic="INVD">
        <description>Invalidate Cache</description>
    </op>
    <op bitmask="0000111100000001xx111" mneumonic="INVLPG">
        <description>Invalidate TLB Entry</description>
    </op>
    <op bitmask="11001111" mneumonic="IRET/IRETD">
        <description>Interrupt Return</description>
    </op>
    <op bitmask="11100011" mneumonic="JCXZ/JECXZ">
        <arg direction="input" type="imm" />
        <description>Jump on CX/ECX Zero Address-size prefix differentiates JCXZ and JECXZ</description>
    </op>
    <op bitmask="11101001" mneumonic="JMP" detail="direct">
        <arg direction="input" type="imm" />
        <description>Unconditional Jump (to same segment)</description>
    </op>
    <op bitmask="11101010" mneumonic="JMP" detail="direct intersegment">
        <arg direction="input" type="imm" />
        <description>Unconditional Jump (to other segment)</description>
    </op>
    <op bitmask="11101011" mneumonic="JMP" detail="short">
        <arg direction="input" type="imm" />
        <description>Unconditional Jump (to same segment)</description>
    </op>
    <op bitmask="1111111111100" mneumonic="JMP" detail="register indirect">
        <arg direction="input" type="reg" />
        <description>Unconditional Jump (to same segment)</description>
    </op>
    <op bitmask="11111111xx100" mneumonic="JMP" detail="memory indirect">
        <arg direction="input" type="mem" />
        <description>Unconditional Jump (to same segment)</description>
    </op>
    <op bitmask="11111111xx101" mneumonic="JMP" detail="indirect intersegment">
        <arg direction="input" type="reg" />
        <description>Unconditional Jump (to other segment)</description>
    </op>
    <op bitmask="0000111110000000" mneumonic="Jcc" detail="full displacement" conditional="O">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Overflow</description>
    </op>
    <op bitmask="0000111110000001" mneumonic="Jcc" detail="full displacement" conditional="NO">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: No overflow</description>
    </op>
    <op bitmask="0000111110000010" mneumonic="Jcc" detail="full displacement" conditional="B">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Below</description>
    </op>
    <op bitmask="0000111110000011" mneumonic="Jcc" detail="full displacement" conditional="NB">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not below</description>
    </op>
    <op bitmask="0000111110000100" mneumonic="Jcc" detail="full displacement" conditional="E">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Equals</description>
    </op>
    <op bitmask="0000111110000101" mneumonic="Jcc" detail="full displacement" conditional="NE">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not equals</description>
    </op>
    <op bitmask="0000111110000110" mneumonic="Jcc" detail="full displacement" conditional="NA">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not above</description>
    </op>
    <op bitmask="0000111110000111" mneumonic="Jcc" detail="full displacement" conditional="A">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Above</description>
    </op>
    <op bitmask="0000111110001000" mneumonic="Jcc" detail="full displacement" conditional="S">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Sign</description>
    </op>
    <op bitmask="0000111110001001" mneumonic="Jcc" detail="full displacement" conditional="NS">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not sign</description>
    </op>
    <op bitmask="0000111110001010" mneumonic="Jcc" detail="full displacement" conditional="P">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Parity</description>
    </op>
    <op bitmask="0000111110001011" mneumonic="Jcc" detail="full displacement" conditional="NP">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not parity</description>
    </op>
    <op bitmask="0000111110001100" mneumonic="Jcc" detail="full displacement" conditional="L">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Less than</description>
    </op>
    <op bitmask="0000111110001101" mneumonic="Jcc" detail="full displacement" conditional="NL">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not less than</description>
    </op>
    <op bitmask="0000111110001110" mneumonic="Jcc" detail="full displacement" conditional="NG">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not greater than</description>
    </op>
    <op bitmask="0000111110001111" mneumonic="Jcc" detail="full displacement" conditional="G">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Greater than</description>
    </op>
    <op bitmask="01110000" mneumonic="Jcc" detail="8-bit displacement" conditional="O">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Overflow</description>
    </op>
    <op bitmask="01110001" mneumonic="Jcc" detail="8-bit displacement" conditional="NO">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: No overflow</description>
    </op>
    <op bitmask="01110010" mneumonic="Jcc" detail="8-bit displacement" conditional="B">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Below</description>
    </op>
    <op bitmask="01110011" mneumonic="Jcc" detail="8-bit displacement" conditional="NB">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not below</description>
    </op>
    <op bitmask="01110100" mneumonic="Jcc" detail="8-bit displacement" conditional="E">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Equals</description>
    </op>
    <op bitmask="01110101" mneumonic="Jcc" detail="8-bit displacement" conditional="NE">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not equals</description>
    </op>
    <op bitmask="01110110" mneumonic="Jcc" detail="8-bit displacement" conditional="NA">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not above</description>
    </op>
    <op bitmask="01110111" mneumonic="Jcc" detail="8-bit displacement" conditional="A">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Above</description>
    </op>
    <op bitmask="01111000" mneumonic="Jcc" detail="8-bit displacement" conditional="S">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Sign</description>
    </op>
    <op bitmask="01111001" mneumonic="Jcc" detail="8-bit displacement" conditional="NS">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not sign</description>
    </op>
    <op bitmask="01111010" mneumonic="Jcc" detail="8-bit displacement" conditional="P">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Parity</description>
    </op>
    <op bitmask="01111011" mneumonic="Jcc" detail="8-bit displacement" conditional="NP">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not parity</description>
    </op>
    <op bitmask="01111100" mneumonic="Jcc" detail="8-bit displacement" conditional="L">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Less than</description>
    </op>
    <op bitmask="01111101" mneumonic="Jcc" detail="8-bit displacement" conditional="NL">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not less than</description>
    </op>
    <op bitmask="01111110" mneumonic="Jcc" detail="8-bit displacement" conditional="NG">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Not greater than</description>
    </op>
    <op bitmask="01111111" mneumonic="Jcc" detail="8-bit displacement" conditional="G">
        <arg direction="input" type="imm" />
        <description>Jump if Condition is Met: Greater than</description>
    </op>
    <op bitmask="10011111" mneumonic="LAHF">
        <arg direction="output" type="AHRegister" />
        <description>Load Flags into AHRegister</description>
    </op>
    <op bitmask="0000111100000010" mneumonic="LAR" detail="from memory">
        <arg direction="input" type="mem" />
        <description>Load Access Rights Byte</description>
    </op>
    <op bitmask="000011110000001011" mneumonic="LAR" detail="from register">
        <arg direction="input" type="reg" />
        <description>Load Access Rights Byte</description>
    </op>
    <op bitmask="111100100000111111110000" mneumonic="LDDQU" detail="xmm, m128">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmm" />
        <description>Load unaligned integer 128-bit</description>
    </op>
    <op bitmask="0000111110101110xx010" mneumonic="LDMXCSR" detail="m32 to MXCSR">
        <arg direction="input" type="mem" />
        <arg direction="output" type="MXCSR" />
        <description>Load MXCSR Register State</description>
    </op>
    <op bitmask="11000101" mneumonic="LDS">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Load Pointer to DS</description>
    </op>
    <op bitmask="10001101" mneumonic="LEA">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Load Effective Address</description>
    </op>
    <op bitmask="11001001" mneumonic="LEAVE">
        <description>High Level Procedure Exit</description>
    </op>
    <op bitmask="11000100" mneumonic="LES">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Load Pointer to ES</description>
    </op>
    <op bitmask="000011111010111011101000" mneumonic="LFENCE">
        <description>Load Fence</description>
    </op>
    <op bitmask="0000111110110100" mneumonic="LFS">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Load Pointer to FS</description>
    </op>
    <op bitmask="0000111100000001xx010" mneumonic="LGDT">
        <description>Load Global Descriptor Table Register</description>
    </op>
    <op bitmask="0000111110110101" mneumonic="LGS">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Load Pointer to GS</description>
    </op>
    <op bitmask="0000111100000001xx011" mneumonic="LIDT">
        <description>Load Interrupt Descriptor Table Register</description>
    </op>
    <op bitmask="000011110000000011010" mneumonic="LLDT" detail="LDTR from register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="LDTR" />
        <description>Load Local Descriptor Table Register</description>
    </op>
    <op bitmask="0000111100000000xx010" mneumonic="LLDT" detail="LDTR from memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="LDTR" />
        <description>Load Local Descriptor Table Register</description>
    </op>
    <op bitmask="000011110000000111110" mneumonic="LMSW" detail="from register">
        <arg direction="input" type="reg" />
        <description>Load Machine Status Word</description>
    </op>
    <op bitmask="0000111100000001xx110" mneumonic="LMSW" detail="from memory">
        <arg direction="input" type="mem" />
        <description>Load Machine Status Word</description>
    </op>
    <op bitmask="11110000" mneumonic="LOCK">
        <description>Assert LOCK# Signal Prefix</description>
    </op>
    <op bitmask="1010110" mneumonic="LODS/LODSB/LODSW/LODSD">
        <description>Load String Operand</description>
    </op>
    <op bitmask="11100010" mneumonic="LOOP">
        <arg direction="input" type="imm" />
        <description>Loop Count</description>
    </op>
    <op bitmask="11100000" mneumonic="LOOPNZ/LOOPNE">
        <arg direction="input" type="imm" />
        <description>Loop Count while not Zero/Equal</description>
    </op>
    <op bitmask="11100001" mneumonic="LOOPZ/LOOPE">
        <arg direction="input" type="imm" />
        <description>Loop Count while Zero/Equal</description>
    </op>
    <op bitmask="0000111100000011" mneumonic="LSL" detail="from memory">
        <arg direction="input" type="mem" />
        <description>Load Segment Limit</description>
    </op>
    <op bitmask="000011110000001111" mneumonic="LSL" detail="from register">
        <arg direction="input" type="reg" />
        <description>Load Segment Limit</description>
    </op>
    <op bitmask="0000111110110010" mneumonic="LSS">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Load Pointer to SS</description>
    </op>
    <op bitmask="000011110000000011011" mneumonic="LTR" detail="from register">
        <arg direction="input" type="reg" />
        <description>Load Task Register</description>
    </op>
    <op bitmask="0000111100000000xx011" mneumonic="LTR" detail="from memory">
        <arg direction="input" type="mem" />
        <description>Load Task Register</description>
    </op>
    <op bitmask="01100110000011111111011111" mneumonic="MASKMOVDQU" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Store Selected Bytes of Double Quadword</description>
    </op>
    <op bitmask="000011111111011111" mneumonic="MASKMOVQ" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Store Selected Bytes of Quadword</description>
    </op>
    <op bitmask="011001100000111101011111" mneumonic="MAXPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101111111" mneumonic="MAXPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011111" mneumonic="MAXPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101111111" mneumonic="MAXPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101011111" mneumonic="MAXSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110010000011110101111111" mneumonic="MAXSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100110000111101011111" mneumonic="MAXSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110101111111" mneumonic="MAXSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Maximum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="000011111010111011110000" mneumonic="MFENCE">
        <description>Memory Fence</description>
    </op>
    <op bitmask="011001100000111101011101" mneumonic="MINPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101110111" mneumonic="MINPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011101" mneumonic="MINPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101110111" mneumonic="MINPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101011101" mneumonic="MINSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110010000011110101110111" mneumonic="MINSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100110000111101011101" mneumonic="MINSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110101110111" mneumonic="MINSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Return Minimum Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="000011110000000111001000" mneumonic="MONITOR" detail="eax, ecx, edx">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Set up a linear address range to be monitored by hardware</description>
    </op>
    <op bitmask="000011110010000011" mneumonic="MOV" detail="register from CR0-CR4">
        <arg direction="input" type="CRx" />
        <arg direction="output" type="reg" />
        <description>Move to/from Control Registers</description>
    </op>
    <op bitmask="000011110010000111" mneumonic="MOV" detail="register from DR6-DR7, register from DR4-DR5, register from DR0-DR3">
        <arg direction="input" type="DRx" />
        <arg direction="output" type="reg" />
        <description>Move to/from Debug Registers</description>
    </op>
    <op bitmask="000011110010001011000" mneumonic="MOV" detail="CR0 from register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="CRx" />
        <description>Move to/from Control Registers</description>
    </op>
    <op bitmask="000011110010001011010" mneumonic="MOV" detail="CR2 from register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="CRx" />
        <description>Move to/from Control Registers</description>
    </op>
    <op bitmask="000011110010001011011" mneumonic="MOV" detail="CR3 from register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="CRx" />
        <description>Move to/from Control Registers</description>
    </op>
    <op bitmask="000011110010001011100" mneumonic="MOV" detail="CR4 from register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="CRx" />
        <description>Move to/from Control Registers</description>
    </op>
    <op bitmask="000011110010001111" mneumonic="MOV" detail="DR0-DR3 from register, DR4-DR5 from register, DR6-DR7 from register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="DRx" />
        <description>Move to/from Debug Registers</description>
    </op>
    <op bitmask="1000100" mneumonic="MOV" detail="reg to memory">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Move Data</description>
    </op>
    <op bitmask="1000100x11" mneumonic="MOV" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Move Data</description>
    </op>
    <op bitmask="1000101" mneumonic="MOV" detail="memory to reg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Move Data</description>
    </op>
    <op bitmask="1000101x11" mneumonic="MOV" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Move Data</description>
    </op>
    <op bitmask="10001100" mneumonic="MOV" detail="segment register to memory">
        <arg direction="input" type="SRx" />
        <arg direction="output" type="mem" />
        <description>Move to/from Segment Registers</description>
    </op>
    <op bitmask="1000110011" mneumonic="MOV" detail="segment register to register">
        <arg direction="input" type="SRx" />
        <arg direction="output" type="reg" />
        <description>Move to/from Segment Registers</description>
    </op>
    <op bitmask="10001110" mneumonic="MOV" detail="memory to segment reg, memory to SS">
        <arg direction="input" type="mem" />
        <arg direction="output" type="SRx" />
        <description>Move to/from Segment Registers</description>
    </op>
    <op bitmask="1000111011" mneumonic="MOV" detail="register to segment register, register to SS">
        <arg direction="input" type="reg" />
        <arg direction="output" type="SRx" />
        <description>Move to/from Segment Registers</description>
    </op>
    <op bitmask="1010000" mneumonic="MOV" detail="memory to AL, AX, or EAX">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Move Data</description>
    </op>
    <op bitmask="1010001" mneumonic="MOV" detail="AL, AX, or EAX to memory">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Move Data</description>
    </op>
    <op bitmask="1011" mneumonic="MOV" detail="immediate to register (alternate encoding)">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Move Data</description>
    </op>
    <op bitmask="1100011x11000" mneumonic="MOV" detail="immediate to register">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Move Data</description>
    </op>
    <op bitmask="1100011xxx000" mneumonic="MOV" detail="immediate to memory">
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Move Data</description>
    </op>
    <op bitmask="011001100000111100101000" mneumonic="MOVAPD" detail="xmmreg1 to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Aligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110010100011" mneumonic="MOVAPD" detail="xmmreg1 to xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111100101001" mneumonic="MOVAPD" detail="mem to xmmreg1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110010100111" mneumonic="MOVAPD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100101000" mneumonic="MOVAPS" detail="mem to xmmreg1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110010100011" mneumonic="MOVAPS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100101001" mneumonic="MOVAPS" detail="xmmreg1 to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Aligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110010100111" mneumonic="MOVAPS" detail="xmmreg1 to xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101101110" mneumonic="MOVD" detail="mem to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Move doubleword</description>
    </op>
    <op bitmask="000011110110111011" mneumonic="MOVD" detail="reg to mmreg">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mmreg" />
        <description>Move doubleword</description>
    </op>
    <op bitmask="0000111101111110" mneumonic="MOVD" detail="mem from mmxreg">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mem" />
        <description>Move doubleword</description>
    </op>
    <op bitmask="000011110111111011" mneumonic="MOVD" detail="reg from mmxreg">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="reg" />
        <description>Move doubleword</description>
    </op>
    <op bitmask="011001100000111101101110" mneumonic="MOVD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Doubleword</description>
    </op>
    <op bitmask="01100110000011110110111011" mneumonic="MOVD" detail="reg to xmmeg">
        <arg direction="input" type="reg" />
        <arg direction="output" type="xmmeg" />
        <description>Move Doubleword</description>
    </op>
    <op bitmask="011001100000111101111110" mneumonic="MOVD" detail="mem from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Doubleword</description>
    </op>
    <op bitmask="01100110000011110111111011" mneumonic="MOVD" detail="reg from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Move Doubleword</description>
    </op>
    <op bitmask="111100100000111100010010" mneumonic="MOVDDUP" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move 64 bits representing one DP data from XMM2/Mem to XMM1 and duplicate</description>
    </op>
    <op bitmask="11110010000011110001001011" mneumonic="MOVDDUP" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move 64 bits representing one DP data from XMM2/Mem to XMM1 and duplicate</description>
    </op>
    <op bitmask="11110010000011111101011011" mneumonic="MOVDQ2Q" detail="xmmreg to mmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mmreg" />
        <description>Move Quadword from XMM to MMX Register</description>
    </op>
    <op bitmask="011001100000111101101111" mneumonic="MOVDQA" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Double Quadword</description>
    </op>
    <op bitmask="01100110000011110110111111" mneumonic="MOVDQA" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Double Quadword</description>
    </op>
    <op bitmask="011001100000111101111111" mneumonic="MOVDQA" detail="mem from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Aligned Double Quadword</description>
    </op>
    <op bitmask="01100110000011110111111111" mneumonic="MOVDQA" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Aligned Double Quadword</description>
    </op>
    <op bitmask="111100110000111101101111" mneumonic="MOVDQU" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Double Quadword</description>
    </op>
    <op bitmask="11110011000011110110111111" mneumonic="MOVDQU" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Double Quadword</description>
    </op>
    <op bitmask="111100110000111101111111" mneumonic="MOVDQU" detail="mem from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Unaligned Double Quadword</description>
    </op>
    <op bitmask="11110011000011110111111111" mneumonic="MOVDQU" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Double Quadword</description>
    </op>
    <op bitmask="000011110001001011" mneumonic="MOVHLPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Packed Single-Precision Floating-Point Values High to Low</description>
    </op>
    <op bitmask="011001100000111100010110" mneumonic="MOVHPD" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move High Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111100010111" mneumonic="MOVHPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move High Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010110" mneumonic="MOVHPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move High Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010111" mneumonic="MOVHPS" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move High Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110001011011" mneumonic="MOVLHPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Packed Single-Precision Floating-Point Values Low to High</description>
    </op>
    <op bitmask="011001100000111100010010" mneumonic="MOVLPD" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Low Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111100010011" mneumonic="MOVLPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Low Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010010" mneumonic="MOVLPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Low Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010011" mneumonic="MOVLPS" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Low Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101000011" mneumonic="MOVMSKPD" detail="xmmreg to r32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Extract Packed Double-Precision Floating-Point Sign Mask</description>
    </op>
    <op bitmask="000011110101000011" mneumonic="MOVMSKPS" detail="xmmreg to r32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Extract Packed Single-Precision Floating-Point Sign Mask</description>
    </op>
    <op bitmask="011001100000111111100111" mneumonic="MOVNTDQ" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Store Double Quadword Using Non-Temporal Hint</description>
    </op>
    <op bitmask="0000111111000011" mneumonic="MOVNTI" detail="reg to mem">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Store Doubleword Using Non-Temporal Hint</description>
    </op>
    <op bitmask="011001100000111100101011" mneumonic="MOVNTPD" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint</description>
    </op>
    <op bitmask="0000111100101011" mneumonic="MOVNTPS" detail="xmmreg to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint</description>
    </op>
    <op bitmask="0000111111100111" mneumonic="MOVNTQ" detail="mmreg to mem">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mem" />
        <description>Store Quadword Using Non-Temporal Hint</description>
    </op>
    <op bitmask="0000111101101111" mneumonic="MOVQ" detail="mem to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Move quadword</description>
    </op>
    <op bitmask="000011110110111111" mneumonic="MOVQ" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Move quadword</description>
    </op>
    <op bitmask="0000111101111111" mneumonic="MOVQ" detail="mem from mmxreg">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mem" />
        <description>Move quadword</description>
    </op>
    <op bitmask="000011110111111111" mneumonic="MOVQ" detail="mmxreg2 from mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Move quadword</description>
    </op>
    <op bitmask="011001100000111111010110" mneumonic="MOVQ" detail="mem from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Quadword</description>
    </op>
    <op bitmask="01100110000011111101011011" mneumonic="MOVQ" detail="xmmreg2 from xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Quadword</description>
    </op>
    <op bitmask="111100110000111101111110" mneumonic="MOVQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Quadword</description>
    </op>
    <op bitmask="11110011000011110111111011" mneumonic="MOVQ" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Quadword</description>
    </op>
    <op bitmask="11110011000011111101011011" mneumonic="MOVQ2DQ" detail="mmreg to xmmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Quadword from MMX to XMM Register</description>
    </op>
    <op bitmask="1010010" mneumonic="MOVS/MOVSB/MOVSW/MOVSD">
        <description>Move Data from String to String</description>
    </op>
    <op bitmask="111100100000111100010000" mneumonic="MOVSD" detail="xmmreg1 to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110010000011110001000011" mneumonic="MOVSD" detail="xmmreg1 to xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111100010001" mneumonic="MOVSD" detail="mem to xmmreg1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110010000011110001000111" mneumonic="MOVSD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111100010110" mneumonic="MOVSHDUP" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move 128 bits representing 4 SP data from XMM2/Mem to XMM1 and duplicate high</description>
    </op>
    <op bitmask="11110011000011110001011011" mneumonic="MOVSHDUP" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move 128 bits representing 4 SP data from XMM2/Mem to XMM1 and duplicate high</description>
    </op>
    <op bitmask="111100110000111100010010" mneumonic="MOVSLDUP" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move 128 bits representing 4 SP data from XMM2/Mem to XMM1 and duplicate low 0 - Destination is ST(0) 1 - Destination is ST(i)</description>
    </op>
    <op bitmask="11110011000011110001001011" mneumonic="MOVSLDUP" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move 128 bits representing 4 SP data from XMM2/Mem to XMM1 and duplicate low</description>
    </op>
    <op bitmask="111100110000111100010000" mneumonic="MOVSS" detail="mem to xmmreg1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011110001000011" mneumonic="MOVSS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111100010001" mneumonic="MOVSS" detail="xmmreg1 to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011110001000111" mneumonic="MOVSS" detail="xmmreg1 to xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011111011111" mneumonic="MOVSX" detail="memory to reg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Move with Sign-Extend</description>
    </op>
    <op bitmask="000011111011111x11" mneumonic="MOVSX" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Move with Sign-Extend</description>
    </op>
    <op bitmask="011001100000111100010000" mneumonic="MOVUPD" detail="xmmreg1 to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Unaligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110001000011" mneumonic="MOVUPD" detail="xmmreg1 to xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111100010001" mneumonic="MOVUPD" detail="mem to xmmreg1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110001000111" mneumonic="MOVUPD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010000" mneumonic="MOVUPS" detail="mem to xmmreg1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110001000011" mneumonic="MOVUPS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010001" mneumonic="MOVUPS" detail="xmmreg1 to mem">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Move Unaligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110001000111" mneumonic="MOVUPS" detail="xmmreg1 to xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Move Unaligned Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011111011011" mneumonic="MOVZX" detail="memory to register">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Move with Zero-Extend</description>
    </op>
    <op bitmask="000011111011011x11" mneumonic="MOVZX" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Move with Zero-Extend</description>
    </op>
    <op bitmask="1111011x11100" mneumonic="MUL" detail="AL, AX, or EAX with register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Unsigned Multiply</description>
    </op>
    <op bitmask="1111011xxx100" mneumonic="MUL" detail="AL, AX, or EAX with memory">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Unsigned Multiply</description>
    </op>
    <op bitmask="011001100000111101011001" mneumonic="MULPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101100111" mneumonic="MULPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011001" mneumonic="MULPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101100111" mneumonic="MULPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101011001" mneumonic="MULSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110010000011110101100111" mneumonic="MULSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111101011001" mneumonic="MULSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011110101100111" mneumonic="MULSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110000000111001001" mneumonic="MWAIT" detail="eax, ecx">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Wait until write-back store performed within the range specified by the instruction MONITOR</description>
    </op>
    <op bitmask="1111011x11011" mneumonic="NEG" detail="register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Two's Complement Negation</description>
    </op>
    <op bitmask="1111011xxx011" mneumonic="NEG" detail="memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Two's Complement Negation</description>
    </op>
    <op bitmask="10010000" mneumonic="NOP">
        <description>No Operation</description>
    </op>
    <op bitmask="1111011x11010" mneumonic="NOT" detail="register">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>One's Complement Negation</description>
    </op>
    <op bitmask="1111011xxx010" mneumonic="NOT" detail="memory">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>One's Complement Negation</description>
    </op>
    <op bitmask="0000100" mneumonic="OR" detail="register to memory">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="0000100x11" mneumonic="OR" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="0000101" mneumonic="OR" detail="memory to register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="0000101x11" mneumonic="OR" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="0000110" mneumonic="OR" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="100000xx11001" mneumonic="OR" detail="immediate to register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="100000xxxx001" mneumonic="OR" detail="immediate to memory">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Logical Inclusive OR</description>
    </op>
    <op bitmask="011001100000111101010110" mneumonic="ORPD" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical OR of Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101011011" mneumonic="ORPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical OR of Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101010110" mneumonic="ORPS" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical OR of Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101011011" mneumonic="ORPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical OR of Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="1110011" mneumonic="OUT" detail="fixed port">
        <arg direction="input" type="reg" />
        <arg direction="output" type="imm" />
        <description>Output to Port</description>
    </op>
    <op bitmask="1110111" mneumonic="OUT" detail="variable port">
        <arg direction="input" type="reg" />
        <arg direction="output" type="imm" />
        <description>Output to Port</description>
    </op>
    <op bitmask="0110111" mneumonic="OUTS">
        <description>Output to DX Port</description>
    </op>
    <op bitmask="0000111101101011" mneumonic="PACKSSDW" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Pack dword to word data (signed with saturation)</description>
    </op>
    <op bitmask="000011110110101111" mneumonic="PACKSSDW" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Pack dword to word data (signed with saturation)</description>
    </op>
    <op bitmask="011001100000111101101011" mneumonic="PACKSSDW" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Pack Dword To Word Data (signed with saturation)</description>
    </op>
    <op bitmask="01100110000011110110101111" mneumonic="PACKSSDW" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Pack Dword To Word Data (signed with saturation)</description>
    </op>
    <op bitmask="011001100000111101100011" mneumonic="PACKSSWB" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Pack Word To Byte Data (signed with saturation)</description>
    </op>
    <op bitmask="01100110000011110110001111" mneumonic="PACKSSWB" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Pack Word To Byte Data (signed with saturation)</description>
    </op>
    <op bitmask="0000111101100011" mneumonic="PACKSSWB1" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Pack word to byte data (signed with saturation)</description>
    </op>
    <op bitmask="000011110110001111" mneumonic="PACKSSWB1" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Pack word to byte data (signed with saturation)</description>
    </op>
    <op bitmask="0000111101100111" mneumonic="PACKUSWB" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Pack word to byte data (unsigned with saturation)</description>
    </op>
    <op bitmask="000011110110011111" mneumonic="PACKUSWB" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Pack word to byte data (unsigned with saturation)</description>
    </op>
    <op bitmask="011001100000111101100111" mneumonic="PACKUSWB" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Pack Word To Byte Data (unsigned with saturation)</description>
    </op>
    <op bitmask="01100110000011110110011111" mneumonic="PACKUSWB" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Pack Word To Byte Data (unsigned with saturation)</description>
    </op>
    <op bitmask="00001111111111" mneumonic="PADD" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Add with wrap-around</description>
    </op>
    <op bitmask="00001111111111xx11" mneumonic="PADD" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Add with wrap-around</description>
    </op>
    <op bitmask="0110011000001111111111" mneumonic="PADD" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add With Wrap-around</description>
    </op>
    <op bitmask="0110011000001111111111xx11" mneumonic="PADD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add With Wrap-around</description>
    </op>
    <op bitmask="0000111111010100" mneumonic="PADDQ" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Add Packed Quadword Integers</description>
    </op>
    <op bitmask="000011111101010011" mneumonic="PADDQ" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Add Packed Quadword Integers</description>
    </op>
    <op bitmask="011001100000111111010100" mneumonic="PADDQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Packed Quadword Integers</description>
    </op>
    <op bitmask="01100110000011111101010011" mneumonic="PADDQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Packed Quadword Integers</description>
    </op>
    <op bitmask="00001111111011" mneumonic="PADDS" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Add signed with saturation</description>
    </op>
    <op bitmask="00001111111011xx11" mneumonic="PADDS" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Add signed with saturation</description>
    </op>
    <op bitmask="0110011000001111111011" mneumonic="PADDS" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Signed With Saturation</description>
    </op>
    <op bitmask="0110011000001111111011xx11" mneumonic="PADDS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Signed With Saturation</description>
    </op>
    <op bitmask="00001111110111" mneumonic="PADDUS" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Add unsigned with saturation</description>
    </op>
    <op bitmask="00001111110111xx11" mneumonic="PADDUS" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Add unsigned with saturation</description>
    </op>
    <op bitmask="0110011000001111110111" mneumonic="PADDUS" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Add Unsigned With Saturation</description>
    </op>
    <op bitmask="0110011000001111110111xx11" mneumonic="PADDUS" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Add Unsigned With Saturation</description>
    </op>
    <op bitmask="0000111111011011" mneumonic="PAND" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise And</description>
    </op>
    <op bitmask="000011111101101111" mneumonic="PAND" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise And</description>
    </op>
    <op bitmask="011001100000111111011011" mneumonic="PAND" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise And</description>
    </op>
    <op bitmask="01100110000011111101101111" mneumonic="PAND" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise And</description>
    </op>
    <op bitmask="0000111111011111" mneumonic="PANDN" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise AndNot</description>
    </op>
    <op bitmask="000011111101111111" mneumonic="PANDN" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise AndNot</description>
    </op>
    <op bitmask="011001100000111111011111" mneumonic="PANDN" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise AndNot</description>
    </op>
    <op bitmask="01100110000011111101111111" mneumonic="PANDN" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise AndNot</description>
    </op>
    <op bitmask="1111001110010000" mneumonic="PAUSE">
        <description>Spin Loop Hint</description>
    </op>
    <op bitmask="011001100000111111100000" mneumonic="PAVGB" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="01100110000011111110000011" mneumonic="PAVGB" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="0000111111100000" mneumonic="PAVGB/PAVGW" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="000011111110000011" mneumonic="PAVGB/PAVGW" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="000011111110001111" mneumonic="PAVGB/PAVGW" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="011001100000111111100011" mneumonic="PAVGW" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="01100110000011111110001111" mneumonic="PAVGW" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Average Packed Integers</description>
    </op>
    <op bitmask="00001111011101" mneumonic="PCMPEQ" detail="mmxreg with memory">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mem" />
        <description>Packed compare for equality</description>
    </op>
    <op bitmask="00001111011101xx11" mneumonic="PCMPEQ" detail="mmxreg1 with mmxreg2">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mmxreg" />
        <description>Packed compare for equality</description>
    </op>
    <op bitmask="0110011000001111011101" mneumonic="PCMPEQ" detail="xmmreg with memory">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <description>Packed Compare For Equality</description>
    </op>
    <op bitmask="0110011000001111011101xx11" mneumonic="PCMPEQ" detail="xmmreg1 with xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <description>Packed Compare For Equality</description>
    </op>
    <op bitmask="00001111011001" mneumonic="PCMPGT" detail="mmxreg with memory">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mem" />
        <description>Packed compare greater (signed)</description>
    </op>
    <op bitmask="00001111011001xx11" mneumonic="PCMPGT" detail="mmxreg1 with mmxreg2">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mmxreg" />
        <description>Packed compare greater (signed)</description>
    </op>
    <op bitmask="0110011000001111011001" mneumonic="PCMPGT" detail="xmmreg with memory">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <description>Packed Compare Greater (signed)</description>
    </op>
    <op bitmask="0110011000001111011001xx11" mneumonic="PCMPGT" detail="xmmreg1 with xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <description>Packed Compare Greater (signed)</description>
    </op>
    <op bitmask="000011111100010111" mneumonic="PEXTRW" detail="mmreg to reg32, imm8">
        <arg direction="input" type="mmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Extract Word</description>
    </op>
    <op bitmask="0000111111100011" mneumonic="PEXTRW">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Extract Word</description>
    </op>
    <op bitmask="01100110000011111100010111" mneumonic="PEXTRW" detail="xmmreg to reg32, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Extract Word</description>
    </op>
    <op bitmask="0000111111000100" mneumonic="PINSRW" detail="m16 to mmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mmreg" />
        <description>Insert Word</description>
    </op>
    <op bitmask="000011111100010011" mneumonic="PINSRW" detail="reg32 to mmreg, imm8">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mmreg" />
        <description>Insert Word</description>
    </op>
    <op bitmask="011001100000111111000100" mneumonic="PINSRW" detail="m16 to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Insert Word</description>
    </op>
    <op bitmask="01100110000011111100010011" mneumonic="PINSRW" detail="reg32 to xmmreg, imm8">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Insert Word</description>
    </op>
    <op bitmask="0000111111110101" mneumonic="PMADDWD" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Packed multiply add</description>
    </op>
    <op bitmask="000011111111010111" mneumonic="PMADDWD" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Packed multiply add</description>
    </op>
    <op bitmask="011001100000111111110101" mneumonic="PMADDWD" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Multiply Add</description>
    </op>
    <op bitmask="01100110000011111111010111" mneumonic="PMADDWD" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Multiply Add</description>
    </op>
    <op bitmask="0000111111101110" mneumonic="PMAXSW" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Maximum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="000011111110111011" mneumonic="PMAXSW" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Maximum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="011001100000111111101110" mneumonic="PMAXSW" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Maximum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="01100110000011111110111011" mneumonic="PMAXSW" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Maximum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="0000111111011110" mneumonic="PMAXUB" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Maximum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="000011111101111011" mneumonic="PMAXUB" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Maximum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="011001100000111111011110" mneumonic="PMAXUB" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Maximum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="01100110000011111101111011" mneumonic="PMAXUB" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Maximum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="0000111111101010" mneumonic="PMINSW" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Minimum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="000011111110101011" mneumonic="PMINSW" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Minimum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="011001100000111111101010" mneumonic="PMINSW" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Minimum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="01100110000011111110101011" mneumonic="PMINSW" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Minimum of Packed Signed Word Integers</description>
    </op>
    <op bitmask="0000111111011010" mneumonic="PMINUB" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Minimum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="000011111101101011" mneumonic="PMINUB" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Minimum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="011001100000111111011010" mneumonic="PMINUB" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Minimum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="01100110000011111101101011" mneumonic="PMINUB" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Minimum of Packed Unsigned Byte Integers</description>
    </op>
    <op bitmask="000011111101011111" mneumonic="PMOVMSKB" detail="mmreg to reg32">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="reg" />
        <description>Move Byte Mask To Integer</description>
    </op>
    <op bitmask="01100110000011111101011111" mneumonic="PMOVMSKB" detail="xmmreg to reg32">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="reg" />
        <description>Move Byte Mask To Integer</description>
    </op>
    <op bitmask="0000111111100100" mneumonic="PMULHUW" detail="memory to mmxreg, mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Multiply Packed Unsigned Integers and Store High Result</description>
    </op>
    <op bitmask="000011111110010011" mneumonic="PMULHUW" detail="mmxreg2 to mmxreg1, mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Multiply Packed Unsigned Integers and Store High Result</description>
    </op>
    <op bitmask="011001100000111111100100" mneumonic="PMULHUW" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed multiplication, store high word (unsigned)</description>
    </op>
    <op bitmask="01100110000011111110010011" mneumonic="PMULHUW" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed multiplication, store high word (unsigned)</description>
    </op>
    <op bitmask="0000111111100101" mneumonic="PMULHW" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Packed multiplication, store high word</description>
    </op>
    <op bitmask="000011111110010111" mneumonic="PMULHW" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Packed multiplication, store high word</description>
    </op>
    <op bitmask="011001100000111111100101" mneumonic="PMULHW" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Multiplication, store high word</description>
    </op>
    <op bitmask="01100110000011111110010111" mneumonic="PMULHW" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Multiplication, store high word</description>
    </op>
    <op bitmask="0000111111010101" mneumonic="PMULLW" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Packed multiplication, store low word</description>
    </op>
    <op bitmask="000011111101010111" mneumonic="PMULLW" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Packed multiplication, store low word</description>
    </op>
    <op bitmask="011001100000111111010101" mneumonic="PMULLW" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Multiplication, store low word</description>
    </op>
    <op bitmask="01100110000011111101010111" mneumonic="PMULLW" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Multiplication, store low word</description>
    </op>
    <op bitmask="0000111111110100" mneumonic="PMULUDQ" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Multiply Packed Unsigned Doubleword Integers</description>
    </op>
    <op bitmask="000011111111010011" mneumonic="PMULUDQ" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Multiply Packed Unsigned Doubleword Integers</description>
    </op>
    <op bitmask="011001100000111111110100" mneumonic="PMULUDQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Packed Unsigned Doubleword Integers</description>
    </op>
    <op bitmask="01100110000011111111010011" mneumonic="PMULUDQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Multiply Packed Unsigned Doubleword Integers</description>
    </op>
    <op bitmask="0000111110xx001" mneumonic="POP" detail="segment register FS, GS">
        <arg direction="output" type="SRx" />
        <description>Pop a Segment Register from the Stack </description>
    </op>
    <op bitmask="000xx111" mneumonic="POP" detail="segment register DS, ES, segment register SS">
        <arg direction="output" type="SRx" />
        <description>Pop a Segment Register from the Stack </description>
    </op>
    <op bitmask="01011" mneumonic="POP" detail="register (alternate encoding)">
        <arg direction="output" type="reg" />
        <description>Pop a Word from the Stack</description>
    </op>
    <op bitmask="1000111111000" mneumonic="POP" detail="register">
        <arg direction="output" type="reg" />
        <description>Pop a Word from the Stack</description>
    </op>
    <op bitmask="10001111xx000" mneumonic="POP" detail="memory">
        <arg direction="output" type="mem" />
        <description>Pop a Word from the Stack</description>
    </op>
    <op bitmask="01100001" mneumonic="POPA/POPAD">
        <description>Pop All General Registers</description>
    </op>
    <op bitmask="10011101" mneumonic="POPF/POPFD">
        <arg direction="output" type="FLAGS" />
        <description>Pop Stack into FLAGS or EFLAGS Register</description>
    </op>
    <op bitmask="0000111111101011" mneumonic="POR" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise Or</description>
    </op>
    <op bitmask="000011111110101111" mneumonic="POR" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise Or</description>
    </op>
    <op bitmask="011001100000111111101011" mneumonic="POR" detail="xmemory to xmmreg">
        <arg direction="input" type="xmemory" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Or</description>
    </op>
    <op bitmask="01100110000011111110101111" mneumonic="POR" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Or</description>
    </op>
    <op bitmask="0000111100011000xx000" mneumonic="PREFETCHNTA">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Prefetch Non-Temporal to All Cache Levels</description>
    </op>
    <op bitmask="0000111100011000xx001" mneumonic="PREFETCHT0">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Prefetch Temporal to All Cache Levels</description>
    </op>
    <op bitmask="0000111100011000xx010" mneumonic="PREFETCHT1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Prefetch Temporal to First Level Cache</description>
    </op>
    <op bitmask="0000111100011000xx011" mneumonic="PREFETCHT2">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Prefetch Temporal to Second Level Cache</description>
    </op>
    <op bitmask="0000111111110110" mneumonic="PSADBW" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Compute Sum of Absolute Differences</description>
    </op>
    <op bitmask="000011111111011011" mneumonic="PSADBW" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Compute Sum of Absolute Differences</description>
    </op>
    <op bitmask="011001100000111111110110" mneumonic="PSADBW" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Sum of Absolute Differences</description>
    </op>
    <op bitmask="01100110000011111111011011" mneumonic="PSADBW" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Sum of Absolute Differences</description>
    </op>
    <op bitmask="01100110000011110111000011" mneumonic="PSHUFD" detail="xmmreg to xmmreg, imm8, mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed Doublewords imm8</description>
    </op>
    <op bitmask="11110011000011110111000011" mneumonic="PSHUFHW" detail="xmmreg to xmmreg, imm8, mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed High Words</description>
    </op>
    <op bitmask="11110010000011110111000011" mneumonic="PSHUFLW" detail="xmmreg to xmmreg, imm8, mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed Low Words</description>
    </op>
    <op bitmask="000011110111000011" mneumonic="PSHUFW" detail="mmreg to mmreg, imm8, mem to mmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mmreg" />
        <description>Shuffle Packed Words</description>
    </op>
    <op bitmask="0110011000001111011100xx11110" mneumonic="PSLL" detail="xmmreg by immediate">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Left Logical</description>
    </op>
    <op bitmask="0110011000001111111100" mneumonic="PSLL" detail="xmmreg by memory">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Left Logical</description>
    </op>
    <op bitmask="0110011000001111111100xx11" mneumonic="PSLL" detail="xmmreg1 by xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Left Logical</description>
    </op>
    <op bitmask="00001111011100xx11110" mneumonic="PSLL2" detail="mmxreg by immediate">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift left logical</description>
    </op>
    <op bitmask="00001111111100" mneumonic="PSLL2" detail="mmxreg by memory">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift left logical</description>
    </op>
    <op bitmask="00001111111100xx11" mneumonic="PSLL2" detail="mmxreg1 by mmxreg2">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift left logical</description>
    </op>
    <op bitmask="01100110000011110111001111111" mneumonic="PSLLDQ" detail="xmmreg, imm8">
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shift Double Quadword Left Logical</description>
    </op>
    <op bitmask="0110011000001111011100xx11100" mneumonic="PSRA" detail="xmmreg by immediate">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Right Arithmetic</description>
    </op>
    <op bitmask="0110011000001111111000" mneumonic="PSRA" detail="xmmreg by memory">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Right Arithmetic</description>
    </op>
    <op bitmask="0110011000001111111000xx11" mneumonic="PSRA" detail="xmmreg1 by xmmreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Right Arithmetic</description>
    </op>
    <op bitmask="00001111011100xx11100" mneumonic="PSRA2" detail="mmxreg by immediate">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift right arithmetic</description>
    </op>
    <op bitmask="00001111111000" mneumonic="PSRA2" detail="mmxreg by memory">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift right arithmetic</description>
    </op>
    <op bitmask="00001111111000xx11" mneumonic="PSRA2" detail="mmxreg1 by mmxreg2">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift right arithmetic</description>
    </op>
    <op bitmask="00001111011100xx11010" mneumonic="PSRL" detail="mmxreg by immediate">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift right logical</description>
    </op>
    <op bitmask="00001111110100" mneumonic="PSRL" detail="mmxreg by memory">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift right logical</description>
    </op>
    <op bitmask="00001111110100xx11" mneumonic="PSRL" detail="mmxreg1 by mmxreg2">
        <arg direction="input" type="mmxreg" />
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Packed shift right logical</description>
    </op>
    <op bitmask="0110011000001111011100xx11010" mneumonic="PSRL" detail="xmmxreg by immediate">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Right Logical</description>
    </op>
    <op bitmask="0110011000001111110100" mneumonic="PSRL" detail="xmmxreg by memory">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Right Logical</description>
    </op>
    <op bitmask="0110011000001111110100xx11" mneumonic="PSRL" detail="xmmxreg1 by xmmxreg2">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Packed Shift Right Logical</description>
    </op>
    <op bitmask="01100110000011110111001111011" mneumonic="PSRLDQ" detail="xmmreg, imm8">
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shift Double Quadword Right Logical</description>
    </op>
    <op bitmask="00001111111110" mneumonic="PSUB" detail="memory from mmxreg">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mem" />
        <description>Subtract with wrap-around</description>
    </op>
    <op bitmask="00001111111110xx11" mneumonic="PSUB" detail="mmxreg2 from mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Subtract with wrap-around</description>
    </op>
    <op bitmask="0110011000001111111110" mneumonic="PSUB" detail="memory from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Subtract With Wrap-around</description>
    </op>
    <op bitmask="0110011000001111111110xx11" mneumonic="PSUB" detail="xmmreg2 from xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract With Wrap-around</description>
    </op>
    <op bitmask="0000111111111011" mneumonic="PSUBQ" detail="mem to mmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmreg" />
        <description>Subtract Packed Quadword Integers</description>
    </op>
    <op bitmask="000011111111101111" mneumonic="PSUBQ" detail="mmreg to mmreg">
        <arg direction="input" type="mmreg" />
        <arg direction="output" type="mmreg" />
        <description>Subtract Packed Quadword Integers</description>
    </op>
    <op bitmask="011001100000111111111011" mneumonic="PSUBQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Packed Quadword Integers</description>
    </op>
    <op bitmask="01100110000011111111101111" mneumonic="PSUBQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Packed Quadword Integers</description>
    </op>
    <op bitmask="00001111111010" mneumonic="PSUBS" detail="memory from mmxreg">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mem" />
        <description>Subtract signed with saturation</description>
    </op>
    <op bitmask="00001111111010xx11" mneumonic="PSUBS" detail="mmxreg2 from mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Subtract signed with saturation</description>
    </op>
    <op bitmask="0110011000001111111010" mneumonic="PSUBS" detail="memory from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Subtract Signed With Saturation</description>
    </op>
    <op bitmask="0110011000001111111010xx11" mneumonic="PSUBS" detail="xmmreg2 from xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Signed With Saturation</description>
    </op>
    <op bitmask="00001111110110" mneumonic="PSUBUS" detail="memory from mmxreg, memory from xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="mem" />
        <description>Subtract Unsigned With Saturation</description>
    </op>
    <op bitmask="00001111110110xx11" mneumonic="PSUBUS" detail="mmxreg2 from mmxreg1, xmmreg2 from xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Unsigned With Saturation</description>
    </op>
    <op bitmask="00001111011010" mneumonic="PUNPCKH" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Unpack high data to next larger type</description>
    </op>
    <op bitmask="00001111011010xx11" mneumonic="PUNPCKH" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Unpack high data to next larger type</description>
    </op>
    <op bitmask="0110011000001111011010" mneumonic="PUNPCKH" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack High Data To Next Larger Type</description>
    </op>
    <op bitmask="0110011000001111011010xx11" mneumonic="PUNPCKH" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack High Data To Next Larger Type</description>
    </op>
    <op bitmask="011001100000111101101101" mneumonic="PUNPCKHQDQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack High Data</description>
    </op>
    <op bitmask="01100110000011110110110111" mneumonic="PUNPCKHQDQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack High Data</description>
    </op>
    <op bitmask="00001111011000" mneumonic="PUNPCKL" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Unpack low data to next larger type</description>
    </op>
    <op bitmask="00001111011000xx11" mneumonic="PUNPCKL" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Unpack low data to next larger type</description>
    </op>
    <op bitmask="0110011000001111011000" mneumonic="PUNPCKL" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack Low Data To Next Larger Type</description>
    </op>
    <op bitmask="0110011000001111011000xx11" mneumonic="PUNPCKL" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack Low Data To Next Larger Type</description>
    </op>
    <op bitmask="011001100000111101101100" mneumonic="PUNPCKLQDQ" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack Low Data</description>
    </op>
    <op bitmask="01100110000011110110110011" mneumonic="PUNPCKLQDQ" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack Low Data</description>
    </op>
    <op bitmask="0000111110xx000" mneumonic="PUSH" detail="segment register FS,GS">
        <arg direction="input" type="SRx" />
        <description>Push Segment Register onto the Stack</description>
    </op>
    <op bitmask="000xx110" mneumonic="PUSH" detail="segment register CS,DS,ES,SS">
        <arg direction="input" type="SRx" />
        <description>Push Segment Register onto the Stack</description>
    </op>
    <op bitmask="01010" mneumonic="PUSH" detail="register (alternate encoding)">
        <arg direction="input" type="reg" />
        <description>Push Operand onto the Stack</description>
    </op>
    <op bitmask="011010x0" mneumonic="PUSH" detail="immediate">
        <arg direction="input" type="imm" />
        <description>Push Operand onto the Stack</description>
    </op>
    <op bitmask="1111111111110" mneumonic="PUSH" detail="register">
        <arg direction="input" type="reg" />
        <description>Push Operand onto the Stack</description>
    </op>
    <op bitmask="11111111xx110" mneumonic="PUSH" detail="memory">
        <arg direction="input" type="mem" />
        <description>Push Operand onto the Stack</description>
    </op>
    <op bitmask="01100000" mneumonic="PUSHA/PUSHAD">
        <description>Push All General Registers</description>
    </op>
    <op bitmask="10011100" mneumonic="PUSHF/PUSHFD">
        <description>Push Flags Register onto the Stack</description>
    </op>
    <op bitmask="0000111111101111" mneumonic="PXOR" detail="memory to mmxreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise Xor</description>
    </op>
    <op bitmask="000011111110111111" mneumonic="PXOR" detail="mmxreg2 to mmxreg1">
        <arg direction="input" type="mmxreg" />
        <arg direction="output" type="mmxreg" />
        <description>Bitwise Xor</description>
    </op>
    <op bitmask="011001100000111111101111" mneumonic="PXOR" detail="memory to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Xor</description>
    </op>
    <op bitmask="01100110000011111110111111" mneumonic="PXOR" detail="xmmreg2 to xmmreg1">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Xor</description>
    </op>
    <op bitmask="1100000x11010" mneumonic="RCL" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Rotate thru Carry Left</description>
    </op>
    <op bitmask="1100000xxx010" mneumonic="RCL" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Rotate thru Carry Left</description>
    </op>
    <op bitmask="1101000x11010" mneumonic="RCL" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate thru Carry Left</description>
    </op>
    <op bitmask="1101000xxx010" mneumonic="RCL" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Rotate thru Carry Left</description>
    </op>
    <op bitmask="1101001x11010" mneumonic="RCL" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate thru Carry Left</description>
    </op>
    <op bitmask="1101001xxx010" mneumonic="RCL" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Rotate thru Carry Left</description>
    </op>
    <op bitmask="0000111101010011" mneumonic="RCPPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101001111" mneumonic="RCPPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111101010011" mneumonic="RCPSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110101001111" mneumonic="RCPSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="1100000x11011" mneumonic="RCR" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Rotate thru Carry Right</description>
    </op>
    <op bitmask="1100000xxx011" mneumonic="RCR" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Rotate thru Carry Right</description>
    </op>
    <op bitmask="1101000x11011" mneumonic="RCR" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate thru Carry Right</description>
    </op>
    <op bitmask="1101000xxx011" mneumonic="RCR" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Rotate thru Carry Right</description>
    </op>
    <op bitmask="1101001x11011" mneumonic="RCR" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate thru Carry Right</description>
    </op>
    <op bitmask="1101001xxx011" mneumonic="RCR" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Rotate thru Carry Right</description>
    </op>
    <op bitmask="0000111100110010" mneumonic="RDMSR">
        <description>Read from Model-Specific Register</description>
    </op>
    <op bitmask="0000111100110011" mneumonic="RDPMC">
        <description>Read Performance Monitoring Counters</description>
    </op>
    <op bitmask="0000111100110001" mneumonic="RDTSC">
        <description>Read Time-Stamp Counter</description>
    </op>
    <op bitmask="111100110110110" mneumonic="REP INS">
        <description>Input String</description>
    </op>
    <op bitmask="111100111010110" mneumonic="REP LODS">
        <description>Load String</description>
    </op>
    <op bitmask="111100111010010" mneumonic="REP MOVS">
        <description>Move String</description>
    </op>
    <op bitmask="111100110110111" mneumonic="REP OUTS">
        <description>Output String</description>
    </op>
    <op bitmask="111100111010101" mneumonic="REP STOS">
        <description>Store String</description>
    </op>
    <op bitmask="111100111010011" mneumonic="REPE CMPS">
        <description>Compare String</description>
    </op>
    <op bitmask="111100111010111" mneumonic="REPE SCAS">
        <description>Scan String</description>
    </op>
    <op bitmask="111100101010011" mneumonic="REPNE CMPS">
        <description>Compare String</description>
    </op>
    <op bitmask="111100101010111" mneumonic="REPNE SCAS">
        <description>Scan String</description>
    </op>
    <op bitmask="11000010" mneumonic="RET" detail="adding immediate to SP">
        <arg direction="input" type="imm" />
        <arg direction="input" type="reg" />
        <description>Return from Procedure (to same segment)</description>
    </op>
    <op bitmask="11000011" mneumonic="RET" detail="no argument">
        <description>Return from Procedure (to same segment)</description>
    </op>
    <op bitmask="11001010" mneumonic="RET" detail="adding immediate to SP">
        <arg direction="input" type="imm" />
        <arg direction="input" type="reg" />
        <description>Return from Procedure (to other segment)</description>
    </op>
    <op bitmask="11001011" mneumonic="RET" detail="intersegment">
        <description>Return from Procedure (to other segment)</description>
    </op>
    <op bitmask="1100000x11000" mneumonic="ROL" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Rotate Left</description>
    </op>
    <op bitmask="1100000xxx000" mneumonic="ROL" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Rotate Left</description>
    </op>
    <op bitmask="1101000x11000" mneumonic="ROL" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate Left</description>
    </op>
    <op bitmask="1101000xxx000" mneumonic="ROL" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Rotate Left</description>
    </op>
    <op bitmask="1101001x11000" mneumonic="ROL" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate Left</description>
    </op>
    <op bitmask="1101001xxx000" mneumonic="ROL" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Rotate Left</description>
    </op>
    <op bitmask="1100000x11001" mneumonic="ROR" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Rotate Right</description>
    </op>
    <op bitmask="1100000xxx001" mneumonic="ROR" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Rotate Right</description>
    </op>
    <op bitmask="1101000x11001" mneumonic="ROR" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate Right</description>
    </op>
    <op bitmask="1101000xxx001" mneumonic="ROR" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Rotate Right</description>
    </op>
    <op bitmask="1101001x11001" mneumonic="ROR" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Rotate Right</description>
    </op>
    <op bitmask="1101001xxx001" mneumonic="ROR" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Rotate Right</description>
    </op>
    <op bitmask="0000111110101010" mneumonic="RSM">
        <description>Resume from System Management Mode</description>
    </op>
    <op bitmask="0000111101010010" mneumonic="RSQRTPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101001011" mneumonic="RSQRTPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111101010010" mneumonic="RSQRTSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Square Roots of Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110101001011" mneumonic="RSQRTSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Reciprocals of Square Roots of Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="10011110" mneumonic="SAHF">
        <arg direction="output" type="Flags" />
        <description>Store AH into Flags</description>
    </op>
    <op bitmask="1100000x11111" mneumonic="SAR" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Shift Arithmetic Right</description>
    </op>
    <op bitmask="1100000xxx111" mneumonic="SAR" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Shift Arithmetic Right</description>
    </op>
    <op bitmask="1101000x11111" mneumonic="SAR" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Shift Arithmetic Right</description>
    </op>
    <op bitmask="1101000xxx111" mneumonic="SAR" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Shift Arithmetic Right</description>
    </op>
    <op bitmask="1101001x11111" mneumonic="SAR" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Shift Arithmetic Right</description>
    </op>
    <op bitmask="1101001xxx111" mneumonic="SAR" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Shift Arithmetic Right</description>
    </op>
    <op bitmask="0001100" mneumonic="SBB" detail="register to memory">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="0001100x11" mneumonic="SBB" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="0001101" mneumonic="SBB" detail="memory to register">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="0001101x11" mneumonic="SBB" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="0001110" mneumonic="SBB" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="100000xx11011" mneumonic="SBB" detail="immediate to register">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="100000xxxx011" mneumonic="SBB" detail="immediate to memory">
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Integer Subtraction with Borrow</description>
    </op>
    <op bitmask="1010111" mneumonic="SCAS/SCASB/SCASW/SCASD">
        <description>Scan String</description>
    </op>
    <op bitmask="000011111001000011000" mneumonic="SETcc" detail="register" conditional="O">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Overflow</description>
    </op>
    <op bitmask="0000111110010000xx000" mneumonic="SETcc" detail="memory" conditional="O">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Overflow</description>
    </op>
    <op bitmask="000011111001000111000" mneumonic="SETcc" detail="register" conditional="NO">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: No overflow</description>
    </op>
    <op bitmask="0000111110010001xx000" mneumonic="SETcc" detail="memory" conditional="NO">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: No overflow</description>
    </op>
    <op bitmask="000011111001001011000" mneumonic="SETcc" detail="register" conditional="B">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Below</description>
    </op>
    <op bitmask="0000111110010010xx000" mneumonic="SETcc" detail="memory" conditional="B">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Below</description>
    </op>
    <op bitmask="000011111001001111000" mneumonic="SETcc" detail="register" conditional="NB">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not below</description>
    </op>
    <op bitmask="0000111110010011xx000" mneumonic="SETcc" detail="memory" conditional="NB">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not below</description>
    </op>
    <op bitmask="000011111001010011000" mneumonic="SETcc" detail="register" conditional="E">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Equals</description>
    </op>
    <op bitmask="0000111110010100xx000" mneumonic="SETcc" detail="memory" conditional="E">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Equals</description>
    </op>
    <op bitmask="000011111001010111000" mneumonic="SETcc" detail="register" conditional="NE">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not equals</description>
    </op>
    <op bitmask="0000111110010101xx000" mneumonic="SETcc" detail="memory" conditional="NE">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not equals</description>
    </op>
    <op bitmask="000011111001011011000" mneumonic="SETcc" detail="register" conditional="NA">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not above</description>
    </op>
    <op bitmask="0000111110010110xx000" mneumonic="SETcc" detail="memory" conditional="NA">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not above</description>
    </op>
    <op bitmask="000011111001011111000" mneumonic="SETcc" detail="register" conditional="A">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Above</description>
    </op>
    <op bitmask="0000111110010111xx000" mneumonic="SETcc" detail="memory" conditional="A">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Above</description>
    </op>
    <op bitmask="000011111001100011000" mneumonic="SETcc" detail="register" conditional="S">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Sign</description>
    </op>
    <op bitmask="0000111110011000xx000" mneumonic="SETcc" detail="memory" conditional="S">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Sign</description>
    </op>
    <op bitmask="000011111001100111000" mneumonic="SETcc" detail="register" conditional="NS">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not sign</description>
    </op>
    <op bitmask="0000111110011001xx000" mneumonic="SETcc" detail="memory" conditional="NS">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not sign</description>
    </op>
    <op bitmask="000011111001101011000" mneumonic="SETcc" detail="register" conditional="P">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Parity</description>
    </op>
    <op bitmask="0000111110011010xx000" mneumonic="SETcc" detail="memory" conditional="P">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Parity</description>
    </op>
    <op bitmask="000011111001101111000" mneumonic="SETcc" detail="register" conditional="NP">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not parity</description>
    </op>
    <op bitmask="0000111110011011xx000" mneumonic="SETcc" detail="memory" conditional="NP">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not parity</description>
    </op>
    <op bitmask="000011111001110011000" mneumonic="SETcc" detail="register" conditional="L">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Less than</description>
    </op>
    <op bitmask="0000111110011100xx000" mneumonic="SETcc" detail="memory" conditional="L">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Less than</description>
    </op>
    <op bitmask="000011111001110111000" mneumonic="SETcc" detail="register" conditional="NL">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not less than</description>
    </op>
    <op bitmask="0000111110011101xx000" mneumonic="SETcc" detail="memory" conditional="NL">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not less than</description>
    </op>
    <op bitmask="000011111001111011000" mneumonic="SETcc" detail="register" conditional="NG">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Not greater than</description>
    </op>
    <op bitmask="0000111110011110xx000" mneumonic="SETcc" detail="memory" conditional="NG">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Not greater than</description>
    </op>
    <op bitmask="000011111001111111000" mneumonic="SETcc" detail="register" conditional="G">
        <arg direction="output" type="reg" />
        <description>Byte Set on Condition: Greater than</description>
    </op>
    <op bitmask="0000111110011111xx000" mneumonic="SETcc" detail="memory" conditional="G">
        <arg direction="output" type="mem" />
        <description>Byte Set on Condition: Greater than</description>
    </op>
    <op bitmask="000011111010111011111000" mneumonic="SFENCE">
        <description>Store Fence</description>
    </op>
    <op bitmask="0000111100000001xx000" mneumonic="SGDT">
        <description>Store Global Descriptor Table Register</description>
    </op>
    <op bitmask="1100000x11100" mneumonic="SHL" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Shift Left</description>
    </op>
    <op bitmask="1100000xxx100" mneumonic="SHL" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Shift Left</description>
    </op>
    <op bitmask="1101000x11100" mneumonic="SHL" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Shift Left</description>
    </op>
    <op bitmask="1101000xxx100" mneumonic="SHL" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Shift Left</description>
    </op>
    <op bitmask="1101001x11100" mneumonic="SHL" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Shift Left</description>
    </op>
    <op bitmask="1101001xxx100" mneumonic="SHL" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Shift Left</description>
    </op>
    <op bitmask="0000111110100100" mneumonic="SHLD" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Double Precision Shift Left</description>
    </op>
    <op bitmask="000011111010010011" mneumonic="SHLD" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Double Precision Shift Left</description>
    </op>
    <op bitmask="0000111110100101" mneumonic="SHLD" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Double Precision Shift Left</description>
    </op>
    <op bitmask="000011111010010111" mneumonic="SHLD" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Double Precision Shift Left</description>
    </op>
    <op bitmask="1100000x11101" mneumonic="SHR" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Shift Right</description>
    </op>
    <op bitmask="1100000xxx101" mneumonic="SHR" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Shift Right</description>
    </op>
    <op bitmask="1101000x11101" mneumonic="SHR" detail="register by 1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Shift Right</description>
    </op>
    <op bitmask="1101000xxx101" mneumonic="SHR" detail="memory by 1">
        <arg direction="input" type="mem" />
        <arg direction="output" type="mem" />
        <description>Shift Right</description>
    </op>
    <op bitmask="1101001x11101" mneumonic="SHR" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Shift Right</description>
    </op>
    <op bitmask="1101001xxx101" mneumonic="SHR" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Shift Right</description>
    </op>
    <op bitmask="0000111110101100" mneumonic="SHRD" detail="memory by immediate count">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Double Precision Shift Right</description>
    </op>
    <op bitmask="000011111010110011" mneumonic="SHRD" detail="register by immediate count">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Double Precision Shift Right</description>
    </op>
    <op bitmask="0000111110101101" mneumonic="SHRD" detail="memory by CL">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Double Precision Shift Right</description>
    </op>
    <op bitmask="000011111010110111" mneumonic="SHRD" detail="register by CL">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Double Precision Shift Right</description>
    </op>
    <op bitmask="011001100000111111000110" mneumonic="SHUFPD" detail="mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed Double-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="01100110000011111100011011" mneumonic="SHUFPD" detail="xmmreg to xmmreg, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed Double-Precision Floating-Point Values imm8</description>
    </op>
    <op bitmask="0000111111000110" mneumonic="SHUFPS" detail="mem to xmmreg, imm8">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011111100011011" mneumonic="SHUFPS" detail="xmmreg to xmmreg, imm8">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="xmmreg" />
        <description>Shuffle Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100000001xx001" mneumonic="SIDT">
        <description>Store Interrupt Descriptor Table Register</description>
    </op>
    <op bitmask="000011110000000011000" mneumonic="SLDT" detail="to register">
        <arg direction="output" type="reg" />
        <description>Store Local Descriptor Table Register</description>
    </op>
    <op bitmask="0000111100000000xx000" mneumonic="SLDT" detail="to memory">
        <arg direction="output" type="mem" />
        <description>Store Local Descriptor Table Register</description>
    </op>
    <op bitmask="000011110000000111100" mneumonic="SMSW" detail="to register">
        <arg direction="output" type="reg" />
        <description>Store Machine Status Word</description>
    </op>
    <op bitmask="0000111100000001xx100" mneumonic="SMSW" detail="to memory">
        <arg direction="output" type="mem" />
        <description>Store Machine Status Word</description>
    </op>
    <op bitmask="011001100000111101010001" mneumonic="SQRTPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Roots of Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101000111" mneumonic="SQRTPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Roots of Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101010001" mneumonic="SQRTPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Roots of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101000111" mneumonic="SQRTPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Roots of Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101010001" mneumonic="SQRTSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Root of Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110010000011110101000111" mneumonic="SQRTSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Root of Scalar Double-Precision Floating-Point Value</description>
    </op>
    <op bitmask="111100110000111101010001" mneumonic="SQRTSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Root of Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11110011000011110101000111" mneumonic="SQRTSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Compute Square Root of Scalar Single-Precision Floating-Point Value</description>
    </op>
    <op bitmask="11111001" mneumonic="STC">
        <description>Set Carry Flag</description>
    </op>
    <op bitmask="11111101" mneumonic="STD">
        <description>Set Direction Flag</description>
    </op>
    <op bitmask="11111011" mneumonic="STI">
        <description>Set Interrupt Flag</description>
    </op>
    <op bitmask="0000111110101110xx011" mneumonic="STMXCSR" detail="MXCSR to mem">
        <arg direction="input" type="MXCSR" />
        <arg direction="output" type="mem" />
        <description>Store MXCSR Register State</description>
    </op>
    <op bitmask="1010101" mneumonic="STOS/STOSB/STOSW/STOSD">
        <description>Store String Data</description>
    </op>
    <op bitmask="000011110000000011001" mneumonic="STR" detail="to register">
        <arg direction="output" type="reg" />
        <description>Store Task Register</description>
    </op>
    <op bitmask="0000111100000000xx001" mneumonic="STR" detail="to memory">
        <arg direction="output" type="mem" />
        <description>Store Task Register</description>
    </op>
    <op bitmask="0010100" mneumonic="SUB" detail="register to memory">
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="0010100x11" mneumonic="SUB" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="0010101" mneumonic="SUB" detail="memory to register">
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="0010101x11" mneumonic="SUB" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="0010110" mneumonic="SUB" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="100000xx11101" mneumonic="SUB" detail="immediate to register">
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="100000xxxx101" mneumonic="SUB" detail="immediate to memory">
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Integer Subtraction</description>
    </op>
    <op bitmask="011001100000111101011100" mneumonic="SUBPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101110011" mneumonic="SUBPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101011100" mneumonic="SUBPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101110011" mneumonic="SUBPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100100000111101011100" mneumonic="SUBSD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110010000011110101110011" mneumonic="SUBSD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Scalar Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="111100110000111101011100" mneumonic="SUBSS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="11110011000011110101110011" mneumonic="SUBSS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Subtract Scalar Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100110100" mneumonic="SYSENTER">
        <description>Fast System Call</description>
    </op>
    <op bitmask="0000111100110101" mneumonic="SYSEXIT">
        <description>Fast Return from Fast System Call</description>
    </op>
    <op bitmask="1000010" mneumonic="TEST" detail="memory and register">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <description>Logical Compare</description>
    </op>
    <op bitmask="1000010x11" mneumonic="TEST" detail="register1 and register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <description>Logical Compare</description>
    </op>
    <op bitmask="1010100" mneumonic="TEST" detail="immediate and AL, AX, or EAX">
        <arg direction="input" type="imm" />
        <arg direction="input" type="reg" />
        <description>Logical Compare</description>
    </op>
    <op bitmask="1111011x11000" mneumonic="TEST" detail="immediate and register">
        <arg direction="input" type="imm" />
        <arg direction="input" type="reg" />
        <description>Logical Compare</description>
    </op>
    <op bitmask="1111011xxx000" mneumonic="TEST" detail="immediate and memory">
        <arg direction="input" type="imm" />
        <arg direction="input" type="mem" />
        <description>Logical Compare</description>
    </op>
    <op bitmask="011001100000111100101110" mneumonic="UCOMISD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <description>Unordered Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="01100110000011110010111011" mneumonic="UCOMISD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <description>Unordered Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="0000111100101110" mneumonic="UCOMISS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="xmmreg" />
        <description>Unordered Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="000011110010111011" mneumonic="UCOMISS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <description>Unordered Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS</description>
    </op>
    <op bitmask="0000111100001011" mneumonic="UD2">
        <description>Undefined instruction</description>
    </op>
    <op bitmask="011001100000111100010101" mneumonic="UNPCKHPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave High Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110001010111" mneumonic="UNPCKHPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave High Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010101" mneumonic="UNPCKHPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave High Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110001010111" mneumonic="UNPCKHPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave High Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="011001100000111100010100" mneumonic="UNPCKLPD" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave Low Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110001010011" mneumonic="UNPCKLPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave Low Packed Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111100010100" mneumonic="UNPCKLPS" detail="mem to xmmreg">
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave Low Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110001010011" mneumonic="UNPCKLPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Unpack and Interleave Low Packed Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110000000011100" mneumonic="VERR" detail="register">
        <arg direction="input" type="reg" />
        <description>Verify a Segment for Reading</description>
    </op>
    <op bitmask="0000111100000000xx100" mneumonic="VERR" detail="memory">
        <arg direction="input" type="mem" />
        <description>Verify a Segment for Reading</description>
    </op>
    <op bitmask="000011110000000011101" mneumonic="VERW" detail="register">
        <arg direction="input" type="reg" />
        <description>Verify a Segment for Writing</description>
    </op>
    <op bitmask="0000111100000000xx101" mneumonic="VERW" detail="memory">
        <arg direction="input" type="mem" />
        <description>Verify a Segment for Writing</description>
    </op>
    <op bitmask="10011011" mneumonic="WAIT/FWAIT">
        <description>Wait until FPU Ready</description>
    </op>
    <op bitmask="0000111100001001" mneumonic="WBINVD">
        <description>Writeback and Invalidate Data Cache</description>
    </op>
    <op bitmask="0000111100110000" mneumonic="WRMSR">
        <description>Write to Model-Specific Register</description>
    </op>
    <op bitmask="000011111100000" mneumonic="XADD" detail="memory, reg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <arg direction="output" type="reg" />
        <description>Exchange and Add</description>
    </op>
    <op bitmask="000011111100000x11" mneumonic="XADD" detail="register1, register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <arg direction="output" type="reg" />
        <description>Exchange and Add</description>
    </op>
    <op bitmask="1000011" mneumonic="XCHG" detail="memory with reg">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <arg direction="output" type="reg" />
        <description>Exchange Register/Memory with Register</description>
    </op>
    <op bitmask="1000011x11" mneumonic="XCHG" detail="register1 with register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <arg direction="output" type="reg" />
        <description>Exchange Register/Memory with Register</description>
    </op>
    <op bitmask="10010" mneumonic="XCHG" detail="AX or EAX with reg">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <arg direction="output" type="reg" />
        <description>Exchange Register/Memory with Register</description>
    </op>
    <op bitmask="11010111" mneumonic="XLAT/XLATB">
        <description>Table Look-up Translation</description>
    </op>
    <op bitmask="0011000" mneumonic="XOR" detail="register to memory">
        <arg direction="input" type="mem" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="mem" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="0011000x11" mneumonic="XOR" detail="register1 to register2">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="0011001" mneumonic="XOR" detail="memory to register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="reg" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="0011001x11" mneumonic="XOR" detail="register2 to register1">
        <arg direction="input" type="reg" />
        <arg direction="input" type="reg" />
        <arg direction="output" type="reg" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="0011010" mneumonic="XOR" detail="immediate to AL, AX, or EAX">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="100000xx11110" mneumonic="XOR" detail="immediate to register">
        <arg direction="input" type="reg" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="reg" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="100000xxxx110" mneumonic="XOR" detail="immediate to memory">
        <arg direction="input" type="mem" />
        <arg direction="input" type="imm" />
        <arg direction="output" type="mem" />
        <description>Logical Exclusive OR</description>
    </op>
    <op bitmask="011001100000111101010111" mneumonic="XORPD" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical OR of Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="01100110000011110101011111" mneumonic="XORPD" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical OR of Double-Precision Floating-Point Values</description>
    </op>
    <op bitmask="0000111101010111" mneumonic="XORPS" detail="mem to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="mem" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical XOR of Single-Precision Floating-Point Values</description>
    </op>
    <op bitmask="000011110101011111" mneumonic="XORPS" detail="xmmreg to xmmreg">
        <arg direction="input" type="xmmreg" />
        <arg direction="input" type="xmmreg" />
        <arg direction="output" type="xmmreg" />
        <description>Bitwise Logical XOR of Single-Precision Floating-Point Values</description>
    </op>
</oplist>
